{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clash of Piglin Un RTS inspir\u00e9 du Nether de Minecraft Introduction Bienvenue dans Clash of piglin , un jeu de strat\u00e9gie en temps r\u00e9el o\u00f9 deux arm\u00e9es s\u2019affrontent dans les profondeurs du Nether. Chaque joueur doit g\u00e9rer son arm\u00e9e de Piglins et de Ghasts pour an\u00e9antir le bastion ennemi situ\u00e9 \u00e0 l\u2019extr\u00e9mit\u00e9 oppos\u00e9e de la carte. Le jeu combine gestion tactique , contr\u00f4le direct des unit\u00e9s et progression \u00e9conomique . Votre r\u00e9ussite d\u00e9pendra de votre sens de la strat\u00e9gie et de votre capacit\u00e9 \u00e0 exploiter les particularit\u00e9s du terrain du Nether. Objectif D\u00e9truisez le bastion ennemi avant que le v\u00f4tre ne tombe. Chaque joueur d\u00e9fend un bastion : - Si votre bastion est d\u00e9truit \u2192 vous perdez. - Si vous d\u00e9truisez celui de l\u2019adversaire \u2192 vous remportez la partie. Interface du jeu L\u2019interface de Clash of piglin est divis\u00e9e en plusieurs sections : Zone Description Zone centrale Champ de bataille o\u00f9 \u00e9voluent vos troupes Barre lat\u00e9rale gauche Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 1 Barre lat\u00e9rale droite Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 2 Timer Indique le temps depuis le d\u00e9but de la partie Ressources La g\u00e9n\u00e9ration d\u2019or augmente automatiquement en fonction de la dur\u00e9e de la partie : Temps \u00e9coul\u00e9 (minutes) Revenu par seconde 0:00 \u2192 1:00 +0.13 1:00 \u2192 2:00 +0.16 2:00 \u2192 3:00 +0.20 3:00 \u2192 4:00 +0.25 4:00 +0.30 Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire. Vous pourrez obtenir sur les unit\u00e9s adverses vaincus des r\u00e9compenses correspondant \u00e0 10% du co\u00fbt de l'unit\u00e9. Les unit\u00e9s Unit\u00e9 Image Type Cibles R\u00f4le principal Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies D\u00e9tails des unit\u00e9s Piglin Brute Forces : Grande r\u00e9sistance, d\u00e9g\u00e2ts \u00e9lev\u00e9s au corps \u00e0 corps, rapide Faiblesses : Incapable de toucher les unit\u00e9s a\u00e9riennes, limit\u00e9 au corps-\u00e0-corps Co\u00fbt : 350 or Vitesse : rapide R\u00f4le : Encaisser les d\u00e9g\u00e2ts et prot\u00e9ger les unit\u00e9s \u00e0 distance Piglin Arbal\u00e9trier Forces : Polyvalent, port\u00e9e moyenne Faiblesses : Faible d\u00e9fense, DPS moyen Co\u00fbt : 425 or Vitesse : moyenne R\u00f4le : Soutenir les Brutes et contrer les Ghasts Ghast Forces : Vole, bonne port\u00e9e, d\u00e9gats \u00e9lev\u00e9s, cible directement les b\u00e2timents Faiblesses : Incapable de se d\u00e9fendre, faible vitesse d'attaque Co\u00fbt : 820 or Vitesse : moyenne R\u00f4le : D\u00e9truire les b\u00e2timents et assi\u00e9ger le bastion adverse Commandes Action Commande S\u00e9lectionner une unit\u00e9 Clic gauche S\u00e9lection multiple Maintenir clic gauche et glisser D\u00e9placer les troupes Clic droit sur la carte Changer de joueur Ctrl D\u00e9placer la cam\u00e9ra Fl\u00e8ches directionnelles Zoom / D\u00e9zoom Molette de la souris Astuce : Vous pouvez combiner clic gauche + molette pour ajuster rapidement votre zone de contr\u00f4le. Interface d\u2019achat Chaque c\u00f4t\u00e9 de l\u2019\u00e9cran affiche une interface d\u2019achat : - Liste des unit\u00e9s disponibles avec leur co\u00fbt. - Solde actuel d\u2019or . - Barre de vie du bastion . Cliquez sur une unit\u00e9 pour la recruter imm\u00e9diatement , selon vos ressources disponibles. Les troupes apparaissent \u00e0 proximit\u00e9 de votre bastion. Terrain et effets Le champ de bataille du Nether influence vos unit\u00e9s : Type de terrain Apparence Effet principal Netherrack Terrain neutre Blue Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) Red Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) Soul Sand Ralentit les unit\u00e9s terrestres Lava Infranchissable par les unit\u00e9s terrestres Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain. D\u00e9roulement d\u2019une partie Chaque joueur d\u00e9marre avec un bastion et un revenu initial. Achetez vos premi\u00e8res unit\u00e9s via l\u2019interface lat\u00e9rale. D\u00e9ployez-les et positionnez-les strat\u00e9giquement. Les revenus augmentent au fil du temps, permettant plus d\u2019unit\u00e9s. La bataille continue jusqu\u2019\u00e0 la destruction d\u2019un des bastions. Conseils strat\u00e9giques Prot\u00e9gez votre bastion avec un mur de Piglins Brute. Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille. Fin de partie La partie se termine lorsque : - La vie d\u2019un bastion tombe \u00e0 z\u00e9ro. - Le joueur adverse est d\u00e9clar\u00e9 vainqueur . Cr\u00e9dits Clash of Piglin est un projet de d\u00e9veloppement ind\u00e9pendant inspir\u00e9 de l\u2019univers de Minecraft (\u00a9 Mojang Studios). Con\u00e7u et programm\u00e9 par Mallevaey Adrien, Vandenkoornhuyse Lorenzo, Ciolkowski Yann, Pruvost Scotty, Vandewalle J\u00e9rome et Pinceel Matthieu.","title":"Home"},{"location":"#un-rts-inspire-du-nether-de-minecraft","text":"","title":"Un RTS inspir\u00e9 du Nether de Minecraft"},{"location":"#introduction","text":"Bienvenue dans Clash of piglin , un jeu de strat\u00e9gie en temps r\u00e9el o\u00f9 deux arm\u00e9es s\u2019affrontent dans les profondeurs du Nether. Chaque joueur doit g\u00e9rer son arm\u00e9e de Piglins et de Ghasts pour an\u00e9antir le bastion ennemi situ\u00e9 \u00e0 l\u2019extr\u00e9mit\u00e9 oppos\u00e9e de la carte. Le jeu combine gestion tactique , contr\u00f4le direct des unit\u00e9s et progression \u00e9conomique . Votre r\u00e9ussite d\u00e9pendra de votre sens de la strat\u00e9gie et de votre capacit\u00e9 \u00e0 exploiter les particularit\u00e9s du terrain du Nether.","title":"Introduction"},{"location":"#objectif","text":"D\u00e9truisez le bastion ennemi avant que le v\u00f4tre ne tombe. Chaque joueur d\u00e9fend un bastion : - Si votre bastion est d\u00e9truit \u2192 vous perdez. - Si vous d\u00e9truisez celui de l\u2019adversaire \u2192 vous remportez la partie.","title":"Objectif"},{"location":"#interface-du-jeu","text":"L\u2019interface de Clash of piglin est divis\u00e9e en plusieurs sections : Zone Description Zone centrale Champ de bataille o\u00f9 \u00e9voluent vos troupes Barre lat\u00e9rale gauche Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 1 Barre lat\u00e9rale droite Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 2 Timer Indique le temps depuis le d\u00e9but de la partie","title":"Interface du jeu"},{"location":"#ressources","text":"La g\u00e9n\u00e9ration d\u2019or augmente automatiquement en fonction de la dur\u00e9e de la partie : Temps \u00e9coul\u00e9 (minutes) Revenu par seconde 0:00 \u2192 1:00 +0.13 1:00 \u2192 2:00 +0.16 2:00 \u2192 3:00 +0.20 3:00 \u2192 4:00 +0.25 4:00 +0.30 Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire. Vous pourrez obtenir sur les unit\u00e9s adverses vaincus des r\u00e9compenses correspondant \u00e0 10% du co\u00fbt de l'unit\u00e9.","title":"Ressources"},{"location":"#les-unites","text":"Unit\u00e9 Image Type Cibles R\u00f4le principal Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies","title":"Les unit\u00e9s"},{"location":"#details-des-unites","text":"","title":"D\u00e9tails des unit\u00e9s"},{"location":"#piglin-brute","text":"Forces : Grande r\u00e9sistance, d\u00e9g\u00e2ts \u00e9lev\u00e9s au corps \u00e0 corps, rapide Faiblesses : Incapable de toucher les unit\u00e9s a\u00e9riennes, limit\u00e9 au corps-\u00e0-corps Co\u00fbt : 350 or Vitesse : rapide R\u00f4le : Encaisser les d\u00e9g\u00e2ts et prot\u00e9ger les unit\u00e9s \u00e0 distance","title":"Piglin Brute"},{"location":"#piglin-arbaletrier","text":"Forces : Polyvalent, port\u00e9e moyenne Faiblesses : Faible d\u00e9fense, DPS moyen Co\u00fbt : 425 or Vitesse : moyenne R\u00f4le : Soutenir les Brutes et contrer les Ghasts","title":"Piglin Arbal\u00e9trier"},{"location":"#ghast","text":"Forces : Vole, bonne port\u00e9e, d\u00e9gats \u00e9lev\u00e9s, cible directement les b\u00e2timents Faiblesses : Incapable de se d\u00e9fendre, faible vitesse d'attaque Co\u00fbt : 820 or Vitesse : moyenne R\u00f4le : D\u00e9truire les b\u00e2timents et assi\u00e9ger le bastion adverse","title":"Ghast"},{"location":"#commandes","text":"Action Commande S\u00e9lectionner une unit\u00e9 Clic gauche S\u00e9lection multiple Maintenir clic gauche et glisser D\u00e9placer les troupes Clic droit sur la carte Changer de joueur Ctrl D\u00e9placer la cam\u00e9ra Fl\u00e8ches directionnelles Zoom / D\u00e9zoom Molette de la souris Astuce : Vous pouvez combiner clic gauche + molette pour ajuster rapidement votre zone de contr\u00f4le.","title":"Commandes"},{"location":"#interface-dachat","text":"Chaque c\u00f4t\u00e9 de l\u2019\u00e9cran affiche une interface d\u2019achat : - Liste des unit\u00e9s disponibles avec leur co\u00fbt. - Solde actuel d\u2019or . - Barre de vie du bastion . Cliquez sur une unit\u00e9 pour la recruter imm\u00e9diatement , selon vos ressources disponibles. Les troupes apparaissent \u00e0 proximit\u00e9 de votre bastion.","title":"Interface d\u2019achat"},{"location":"#terrain-et-effets","text":"Le champ de bataille du Nether influence vos unit\u00e9s : Type de terrain Apparence Effet principal Netherrack Terrain neutre Blue Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) Red Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) Soul Sand Ralentit les unit\u00e9s terrestres Lava Infranchissable par les unit\u00e9s terrestres Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain.","title":"Terrain et effets"},{"location":"#deroulement-dune-partie","text":"Chaque joueur d\u00e9marre avec un bastion et un revenu initial. Achetez vos premi\u00e8res unit\u00e9s via l\u2019interface lat\u00e9rale. D\u00e9ployez-les et positionnez-les strat\u00e9giquement. Les revenus augmentent au fil du temps, permettant plus d\u2019unit\u00e9s. La bataille continue jusqu\u2019\u00e0 la destruction d\u2019un des bastions.","title":"D\u00e9roulement d\u2019une partie"},{"location":"#conseils-strategiques","text":"Prot\u00e9gez votre bastion avec un mur de Piglins Brute. Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille.","title":"Conseils strat\u00e9giques"},{"location":"#fin-de-partie","text":"La partie se termine lorsque : - La vie d\u2019un bastion tombe \u00e0 z\u00e9ro. - Le joueur adverse est d\u00e9clar\u00e9 vainqueur .","title":"Fin de partie"},{"location":"#credits","text":"Clash of Piglin est un projet de d\u00e9veloppement ind\u00e9pendant inspir\u00e9 de l\u2019univers de Minecraft (\u00a9 Mojang Studios). Con\u00e7u et programm\u00e9 par Mallevaey Adrien, Vandenkoornhuyse Lorenzo, Ciolkowski Yann, Pruvost Scotty, Vandewalle J\u00e9rome et Pinceel Matthieu.","title":"Cr\u00e9dits"},{"location":"ADMIN_DOCS/","text":"\ud83e\uddfe Documentation Technique \u2013 Clash of piglin 1. Informations g\u00e9n\u00e9rales \u00c9l\u00e9ment D\u00e9tail Titre Documentation Administrateur - Clash of piglin Version 1.0 Auteur Zwartkat Date de r\u00e9vision 09/10/2025 R\u00e9f\u00e9rence du document DOC-GD-TECH-001 Public cible D\u00e9veloppeurs, testeurs, int\u00e9grateurs Langage Python 3.11+ Biblioth\u00e8ques principales Pygame 2.6, esper 2. Objet du document Ce document d\u00e9crit l\u2019 architecture logicielle , les modules , la proc\u00e9dure d\u2019installation , les configurations , et la structure du code du jeu Clash of piglin . L\u2019objectif est de permettre \u00e0 tout d\u00e9veloppeur de comprendre le fonctionnement interne du jeu, de le modifier ou de le maintenir. 3. R\u00e9f\u00e9rences normatives ISO/IEC/IEEE 26514:2008 \u2014 Design and development of information for users Documentation Pygame Python 3.11 Standard Library Reference 4. Vue d\u2019ensemble du jeu Clash of piglin est un jeu type RTS inspir\u00e9 de Minecraft Deux joueurs s'affrontent dans l'objectif de d\u00e9truire le bastion de l'adversaire. Fonctionnalit\u00e9s principales D\u00e9placement des troupes Achat de troupes Syst\u00e8me de g\u00e9n\u00e9ration d'argent automatique Interface graphique simple avec menus. 5. Environnement logiciel requis Composant Sp\u00e9cification Langage Python 3.11 ou sup\u00e9rieur Biblioth\u00e8que graphique Pygame 2.6 OS compatibles Windows, macOS, Linux D\u00e9pendances pip install -r requirements.txt IDE recommand\u00e9 VS Code 6. Proc\u00e9dure d\u2019installation 6.1. Cloner le d\u00e9p\u00f4t git clone https://github.com/Zwartkat/Clash-of-Piglin cd Clash-of-Piglin","title":"\ud83e\uddfe Documentation Technique \u2013 Clash of piglin"},{"location":"ADMIN_DOCS/#documentation-technique-clash-of-piglin","text":"","title":"\ud83e\uddfe Documentation Technique \u2013 Clash of piglin"},{"location":"ADMIN_DOCS/#1-informations-generales","text":"\u00c9l\u00e9ment D\u00e9tail Titre Documentation Administrateur - Clash of piglin Version 1.0 Auteur Zwartkat Date de r\u00e9vision 09/10/2025 R\u00e9f\u00e9rence du document DOC-GD-TECH-001 Public cible D\u00e9veloppeurs, testeurs, int\u00e9grateurs Langage Python 3.11+ Biblioth\u00e8ques principales Pygame 2.6, esper","title":"1. Informations g\u00e9n\u00e9rales"},{"location":"ADMIN_DOCS/#2-objet-du-document","text":"Ce document d\u00e9crit l\u2019 architecture logicielle , les modules , la proc\u00e9dure d\u2019installation , les configurations , et la structure du code du jeu Clash of piglin . L\u2019objectif est de permettre \u00e0 tout d\u00e9veloppeur de comprendre le fonctionnement interne du jeu, de le modifier ou de le maintenir.","title":"2. Objet du document"},{"location":"ADMIN_DOCS/#3-references-normatives","text":"ISO/IEC/IEEE 26514:2008 \u2014 Design and development of information for users Documentation Pygame Python 3.11 Standard Library Reference","title":"3. R\u00e9f\u00e9rences normatives"},{"location":"ADMIN_DOCS/#4-vue-densemble-du-jeu","text":"Clash of piglin est un jeu type RTS inspir\u00e9 de Minecraft Deux joueurs s'affrontent dans l'objectif de d\u00e9truire le bastion de l'adversaire.","title":"4. Vue d\u2019ensemble du jeu"},{"location":"ADMIN_DOCS/#fonctionnalites-principales","text":"D\u00e9placement des troupes Achat de troupes Syst\u00e8me de g\u00e9n\u00e9ration d'argent automatique Interface graphique simple avec menus.","title":"Fonctionnalit\u00e9s principales"},{"location":"ADMIN_DOCS/#5-environnement-logiciel-requis","text":"Composant Sp\u00e9cification Langage Python 3.11 ou sup\u00e9rieur Biblioth\u00e8que graphique Pygame 2.6 OS compatibles Windows, macOS, Linux D\u00e9pendances pip install -r requirements.txt IDE recommand\u00e9 VS Code","title":"5. Environnement logiciel requis"},{"location":"ADMIN_DOCS/#6-procedure-dinstallation","text":"","title":"6. Proc\u00e9dure d\u2019installation"},{"location":"ADMIN_DOCS/#61-cloner-le-depot","text":"git clone https://github.com/Zwartkat/Clash-of-Piglin cd Clash-of-Piglin","title":"6.1. Cloner le d\u00e9p\u00f4t"},{"location":"DOCS_TECHNICAL/","text":"Clash-of-piglin Tutoriels ... Afficher un \u00e9lement dans la map Les coordonn\u00e9es trait\u00e9es en arri\u00e8re plan sont les coordonn\u00e9es de l'\u00e9l\u00e9ment dans le monde , celui n'est cependant pas afficher \u00e0 cet emplacement. Pour afficher un \u00e9l\u00e9ment sur la carte, il est imp\u00e9ratif de passer par la Camera . Il n'est pas n\u00e9cessaire d'acc\u00e9der directement \u00e0 la cam\u00e9ra pour afficher l'\u00e9l\u00e9ment souhait\u00e9. La classe RenderSystem permet directement de passer l'\u00e9l\u00e9ment souhait\u00e9 pour l'afficher dans la carte Pour cela, on doit r\u00e9cup\u00e9rer l'instance de RenderSystem est utiliser les m\u00e9thodes suivantes: - draw_surface : pour afficher une Surface pygame - draw_rect : pour dessiner un Rect de pygame - draw_polygon : pour dessiner un Polygon de pygame from systems.rendersystem import RenderSystem screen : pygame.Surface map : Map sprites : dict[CaseType,pygame.Surface] render = RenderSystem(screen,map,sprites) frame = sprite.get_frame() render.draw_surface(frame, x, y) render.draw_rect((x, y, width, height), color) diamond_points: list[tuple[int]] = [ (x, y - 10), # Top (x + 2, y - 8), # right (x, y - 6), # bottom (x - 2, y - 8), # left ] render.draw_polygon(diamond_points, color) Animer une entit\u00e9 L'animation d'une entit\u00e9 d\u00e9pend du composant Sprite \u00e0 sa cr\u00e9ation. La frame courante peut ensuite \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir de la m\u00e9thode get_frame . La m\u00e9thode set_animation permet de d\u00e9finir l'animation et la direction \u00e0 afficher. Elle est g\u00e9n\u00e9ralement utilis\u00e9e dans des m\u00e9thodes appel\u00e9es par l'\u00e9mission d'un Event . Voir EventBus Le Sprite est mis \u00e0 jour via la m\u00e9thode update , qui utilise le delta_time pour d\u00e9cider du changement de frame. Le RenderSystem permet d'effectuer automatiquement la mise \u00e0 jour de la frame \u00e0 afficher Core EventBus L'EventBus est un syst\u00e8me permettant de transmettre des \u00e9v\u00e9nements \u00e0 n'importe quelle m\u00e9thode de classe abonn\u00e9 Cette classe est sous la forme d'un singleton et peut \u00eatre r\u00e9cup\u00e9r\u00e9e avec EventBus.get_event_bus() . La m\u00e9thode subscribe permet en fournissant une classe Event et une m\u00e9thode sous forme de Callable . Pour d\u00e9sabonner, il faut utiliser unsubcribe . Pour \u00e9mettre un \u00e9v\u00e9nement, il doit \u00eatre donn\u00e9 \u00e0 la m\u00e9thode emit qui ex\u00e9cutera toutes les objets m\u00e9thodes abonn\u00e9s. Ces m\u00e9thodes doivent poss\u00e9der en argument l'event qui lui sera transmis from core.ecs.event_bus import EventBus render = RenderSystem() event_bus : EventBus = EventBus.get_event_bus() event_bus.subscribe(MoveEvent, render.animate_move) class RenderSystem: def __init__(self): pass ... def animate_move(self, event : MoveEvent): print(event.pos_x,event.pos_y) IteratingProcessor La classe IteratingProcessor est une classe abstraite qui permet d'effectuer une action \u00e0 d\u00e9finir dans la classe fille. Elle permet d'executer cette action pour toutes les entit\u00e9s qui poss\u00e8dent les Component fournis \u00e0 l'instanciation de la classe par l'interm\u00e9diaire de la m\u00e9thode process_entity . Celle-ci fournit les donn\u00e9es suivantes: - ent (int) : l'identifiant de l'entit\u00e9 dans esper - dt (float) : le delta_time - *comps (Component) : le ou les components fournis \u00e0 la cr\u00e9ation de la classe fille Exemple from component.component1 import Component1 from component.component2 import Component2 class ExempleSystem(IteratingProcessor): def __init__(self): super().__init__(Component1,Component2) def process_entity(self, ent : int, dt : float, comp1: Component1, comp2 : Component2): pass Cam\u00e9ra La cam\u00e9ra affiche uniquement les \u00e9l\u00e9ments aux coordonn\u00e9es correspondant au delta x et y de la cam\u00e9ra (le d\u00e9calage de la cam\u00e9ra par rapport au monde) Pour utiliser la cam\u00e9ra, il est imp\u00e9ratif d'executer ces deux fonctions : set_size et set_world_size from core.game.camera import CAMERA CAMERA.set_size(300,300) CAMERA.set_world_size(700,800) Composants Toutes les entit\u00e9s sont d\u00e9finis par des composants, ceux-ci servent de stockage de donn\u00e9es. Ils d\u00e9pendent tous de Component . Attack Case L'entit\u00e9 Case permet de cr\u00e9er des cases, qui en nombre composent la carte de jeu ( Map ). On peut en cr\u00e9er sans communiquer de param\u00e8tres. La case sera alors cr\u00e9\u00e9e avec des coordonn\u00e9es ( Position ) et un type ( CaseType ) par d\u00e9faut. On peut cependant \u00e9galement cr\u00e9er une Case \u00e0 partir d'une autre (la nouvelle copiera alors les coordonn\u00e9es et le type du mod\u00e8le) via la m\u00e9thode initFromModel . Les propri\u00e9t\u00e9s d'une Case sont : coordonnees (Position) : La position de la case. Sera utilis\u00e9e pour d\u00e9terminer son placement dans le tab de la carte de jeu, ainsi que pour l'affichage de ladite carte. type (CaseType) : Le type de la case. Sera notamment utilis\u00e9 dans la carte de jeu afin de permettre toute sortes d'op\u00e9rations, dont la v\u00e9rification de la g\u00e9n\u00e9ration d'une carte valide. Si la case est de type LAVA , elle re\u00e7oit un composant Sprite qui sera utilis\u00e9 pour g\u00e9rer une animation lors de l'affichage. Les fonctions d'une carte sont : getPosition () -> Position : retourne les coordonn\u00e9es de la case. getType () -> CaseType : retourne le type de la case. setPosition (mod\u00e8le : Position) -> None : copie la position fourni dans les coordonnees de la case. setType (mod\u00e8le : CaseType) -> None : copie le type fourni dans le type de la case. __str__ () -> str : m\u00e9thode permettant d'afficher une case comme une cha\u00eene de caract\u00e8res d\u00e9crivant sa position et son type. Exemple d'impl\u00e9mentation d'une carte : from components.case import Case case = Case() print(carte) Collider Cost Effects Fly Health Map Le composant Map permet de cr\u00e9er des cartes de jeu, repr\u00e9sent\u00e9es par des tables de Case . On peut en cr\u00e9er sans communiquer de param\u00e8tres. Le tableau repr\u00e9sentant le contenu de la carte sera alors initialis\u00e9 comme vide. On peut cependant \u00e9galement cr\u00e9er une carte \u00e0 partir d'une autre (la nouvelle copiera alors le tableau du mod\u00e8le) via la m\u00e9thode initFromModel , ou cr\u00e9er une carte \u00e0 partir d'un tableau (list[list[CaseType]) (la carte utilisera le tableau pour initialiser le sien) via la m\u00e9thode initFromTab . Les propri\u00e9t\u00e9s d'une carte sont : tab (list[list[Case]]) : Le tableau repr\u00e9sentant le contenu de la carte. index (int) : Un index g\u00e9n\u00e9r\u00e9 \u00e0 partir d'un compteur statique, permettant d'identifier la carte. Les d\u00e9tails des propri\u00e9t\u00e9s statiques sont pr\u00e9sent\u00e9s dans le code source, celles-ci \u00e9tant utilis\u00e9es de fa\u00e7on interne. Les m\u00e9thodes d'une carte sont : getTab () -> list[list[Case]] : retourne le tab repr\u00e9sentant le contenu de la carte. getIndex () -> int : retourne l'index de la carte. setTab (mod\u00e8le : list[list[Case]]) -> None : copie le contenu du tableau fourni dans le tab de la carte. changeCase (mod\u00e8le : Case) -> None : remplace la case du tab dont la position est celle du mod\u00e8le par une copie de la case fournie. generate (taille : int) -> None : r\u00e9initialise tab et le remplit d'une carte carr\u00e9e de longueur et largeur \u00e9gale au nombre fourni, g\u00e9n\u00e9r\u00e9e al\u00e9atoirement \u00e0 partir de nombreuses propri\u00e9t\u00e9s internes (voir code source). __str__ () -> str : m\u00e9thode permettant d'afficher une carte comme une cha\u00eene de caract\u00e8res d\u00e9crivant le contenu de son tab. Exemple d'impl\u00e9mentation d'une carte : from core.game.map import Map carte = Map() carte.generate(24) print(carte) Money Position Selection Sprite Le component Sprite permet d'ajouter un sprite \u00e0 une entit\u00e9. Voir Animer une entit\u00e9 Les param\u00e8tres \u00e0 fournir sont : sprite_sheet (str) : La feuille de sprite \u00e0 utiliser pour l'animation. width (int) : La largeur des frames sur la feuille de sprite. height (int) : La hauteur des frames sur la feuille de sprite. animations (dict) : Le d\u00e9tail des animations (voir ci-dessous). frame_duration (float) : La dur\u00e9e en secondes d'une frame. spritesheet_direction (Orientation) : Orientation des frames dans la feuille (HORIZONTAL ou VERTICAL). D\u00e9faut = HORIZONTAL . default_animation (Animation) : L'animation par d\u00e9faut de l'entit\u00e9. D\u00e9faut = IDLE . default_direction (Direction) : La direction par d\u00e9faut de l'entit\u00e9. D\u00e9faut = DOWN . Le param\u00e8tre animations est un dictionnaire qui associe pour chaque type d'animation et pour chaque direction, une liste d'entiers correspondant aux indices des frames sur la feuille de sprite (la premi\u00e8re frame = 0). Exemple de param\u00e8tre animation: { Animation.IDLE: { Direction.DOWN: [1, 5], Direction.UP: [3, 7], Direction.LEFT: [2, 6], Direction.RIGHT: [0, 4], }, Animation.WALK: { Direction.DOWN: [1, 10, 1, 11], Direction.UP: [3, 14, 3, 15], Direction.LEFT: [2, 12, 2, 13], Direction.RIGHT: [0, 8, 0, 9], }, } Squad Stats Structure Target Team Velocity Syst\u00e8mes ... RenderSystem RenderSystem est une classe qui g\u00e8re de fa\u00e7on globale l'affichage. Elle h\u00e9rite de IteratingProcessor ce qui permet d'effectuer des actions sur chaque entit\u00e9s poss\u00e9dant un composant Position et Sprite . Avant l'ex\u00e9cution du process_entity , les entit\u00e9s sont tri\u00e9s par Layer d\u00e9finie par la propri\u00e9t\u00e9 priority de Sprite Son process_entity va afficher les entit\u00e9s concern\u00e9es et \u00e9galement mettre \u00e0 jour l'animation. Lorsque le type d'animation ne vaut pas None , l'entit\u00e9 est consid\u00e9r\u00e9 comme un personnage jouable. Dans ce cas, une barre de vie lui ai ajout\u00e9 au dessus du sprite ainsi qu'un point avec une couleur r\u00e9pr\u00e9sentant son \u00e9quipe et son \u00e9tat de s\u00e9lection. A sa cr\u00e9ation RenderSystem a besoin des 3 \u00e9l\u00e9ments suivants : - une Surface issue de pygame - une Map - un dictionnaire de sprite pour les cases : dict[CaseType,pygame.Surface] M\u00e9thodes : - show_map : affiche la carte (carte d\u00e9finie \u00e0 l'instanciation) - animate_move : m\u00e9thode qui passe les animations de sprite des entit\u00e9s fournit par EventMoveTo - draw_surface : Dessine une surface pygame sur le screen du RenderSystem - draw_rect : Dessine une surface pygame sur le screen du RenderSystem - draw_polygon : Dessine une surface pygame sur le screen du RenderSystem","title":"Clash-of-piglin"},{"location":"DOCS_TECHNICAL/#clash-of-piglin","text":"","title":"Clash-of-piglin"},{"location":"DOCS_TECHNICAL/#tutoriels","text":"...","title":"Tutoriels"},{"location":"DOCS_TECHNICAL/#afficher-un-element-dans-la-map","text":"Les coordonn\u00e9es trait\u00e9es en arri\u00e8re plan sont les coordonn\u00e9es de l'\u00e9l\u00e9ment dans le monde , celui n'est cependant pas afficher \u00e0 cet emplacement. Pour afficher un \u00e9l\u00e9ment sur la carte, il est imp\u00e9ratif de passer par la Camera . Il n'est pas n\u00e9cessaire d'acc\u00e9der directement \u00e0 la cam\u00e9ra pour afficher l'\u00e9l\u00e9ment souhait\u00e9. La classe RenderSystem permet directement de passer l'\u00e9l\u00e9ment souhait\u00e9 pour l'afficher dans la carte Pour cela, on doit r\u00e9cup\u00e9rer l'instance de RenderSystem est utiliser les m\u00e9thodes suivantes: - draw_surface : pour afficher une Surface pygame - draw_rect : pour dessiner un Rect de pygame - draw_polygon : pour dessiner un Polygon de pygame from systems.rendersystem import RenderSystem screen : pygame.Surface map : Map sprites : dict[CaseType,pygame.Surface] render = RenderSystem(screen,map,sprites) frame = sprite.get_frame() render.draw_surface(frame, x, y) render.draw_rect((x, y, width, height), color) diamond_points: list[tuple[int]] = [ (x, y - 10), # Top (x + 2, y - 8), # right (x, y - 6), # bottom (x - 2, y - 8), # left ] render.draw_polygon(diamond_points, color)","title":"Afficher un \u00e9lement dans la map"},{"location":"DOCS_TECHNICAL/#animer-une-entite","text":"L'animation d'une entit\u00e9 d\u00e9pend du composant Sprite \u00e0 sa cr\u00e9ation. La frame courante peut ensuite \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir de la m\u00e9thode get_frame . La m\u00e9thode set_animation permet de d\u00e9finir l'animation et la direction \u00e0 afficher. Elle est g\u00e9n\u00e9ralement utilis\u00e9e dans des m\u00e9thodes appel\u00e9es par l'\u00e9mission d'un Event . Voir EventBus Le Sprite est mis \u00e0 jour via la m\u00e9thode update , qui utilise le delta_time pour d\u00e9cider du changement de frame. Le RenderSystem permet d'effectuer automatiquement la mise \u00e0 jour de la frame \u00e0 afficher","title":"Animer une entit\u00e9"},{"location":"DOCS_TECHNICAL/#core","text":"","title":"Core"},{"location":"DOCS_TECHNICAL/#eventbus","text":"L'EventBus est un syst\u00e8me permettant de transmettre des \u00e9v\u00e9nements \u00e0 n'importe quelle m\u00e9thode de classe abonn\u00e9 Cette classe est sous la forme d'un singleton et peut \u00eatre r\u00e9cup\u00e9r\u00e9e avec EventBus.get_event_bus() . La m\u00e9thode subscribe permet en fournissant une classe Event et une m\u00e9thode sous forme de Callable . Pour d\u00e9sabonner, il faut utiliser unsubcribe . Pour \u00e9mettre un \u00e9v\u00e9nement, il doit \u00eatre donn\u00e9 \u00e0 la m\u00e9thode emit qui ex\u00e9cutera toutes les objets m\u00e9thodes abonn\u00e9s. Ces m\u00e9thodes doivent poss\u00e9der en argument l'event qui lui sera transmis from core.ecs.event_bus import EventBus render = RenderSystem() event_bus : EventBus = EventBus.get_event_bus() event_bus.subscribe(MoveEvent, render.animate_move) class RenderSystem: def __init__(self): pass ... def animate_move(self, event : MoveEvent): print(event.pos_x,event.pos_y)","title":"EventBus"},{"location":"DOCS_TECHNICAL/#iteratingprocessor","text":"La classe IteratingProcessor est une classe abstraite qui permet d'effectuer une action \u00e0 d\u00e9finir dans la classe fille. Elle permet d'executer cette action pour toutes les entit\u00e9s qui poss\u00e8dent les Component fournis \u00e0 l'instanciation de la classe par l'interm\u00e9diaire de la m\u00e9thode process_entity . Celle-ci fournit les donn\u00e9es suivantes: - ent (int) : l'identifiant de l'entit\u00e9 dans esper - dt (float) : le delta_time - *comps (Component) : le ou les components fournis \u00e0 la cr\u00e9ation de la classe fille Exemple from component.component1 import Component1 from component.component2 import Component2 class ExempleSystem(IteratingProcessor): def __init__(self): super().__init__(Component1,Component2) def process_entity(self, ent : int, dt : float, comp1: Component1, comp2 : Component2): pass","title":"IteratingProcessor"},{"location":"DOCS_TECHNICAL/#camera","text":"La cam\u00e9ra affiche uniquement les \u00e9l\u00e9ments aux coordonn\u00e9es correspondant au delta x et y de la cam\u00e9ra (le d\u00e9calage de la cam\u00e9ra par rapport au monde) Pour utiliser la cam\u00e9ra, il est imp\u00e9ratif d'executer ces deux fonctions : set_size et set_world_size from core.game.camera import CAMERA CAMERA.set_size(300,300) CAMERA.set_world_size(700,800)","title":"Cam\u00e9ra"},{"location":"DOCS_TECHNICAL/#composants","text":"Toutes les entit\u00e9s sont d\u00e9finis par des composants, ceux-ci servent de stockage de donn\u00e9es. Ils d\u00e9pendent tous de Component .","title":"Composants"},{"location":"DOCS_TECHNICAL/#attack","text":"","title":"Attack"},{"location":"DOCS_TECHNICAL/#case","text":"L'entit\u00e9 Case permet de cr\u00e9er des cases, qui en nombre composent la carte de jeu ( Map ). On peut en cr\u00e9er sans communiquer de param\u00e8tres. La case sera alors cr\u00e9\u00e9e avec des coordonn\u00e9es ( Position ) et un type ( CaseType ) par d\u00e9faut. On peut cependant \u00e9galement cr\u00e9er une Case \u00e0 partir d'une autre (la nouvelle copiera alors les coordonn\u00e9es et le type du mod\u00e8le) via la m\u00e9thode initFromModel . Les propri\u00e9t\u00e9s d'une Case sont : coordonnees (Position) : La position de la case. Sera utilis\u00e9e pour d\u00e9terminer son placement dans le tab de la carte de jeu, ainsi que pour l'affichage de ladite carte. type (CaseType) : Le type de la case. Sera notamment utilis\u00e9 dans la carte de jeu afin de permettre toute sortes d'op\u00e9rations, dont la v\u00e9rification de la g\u00e9n\u00e9ration d'une carte valide. Si la case est de type LAVA , elle re\u00e7oit un composant Sprite qui sera utilis\u00e9 pour g\u00e9rer une animation lors de l'affichage. Les fonctions d'une carte sont : getPosition () -> Position : retourne les coordonn\u00e9es de la case. getType () -> CaseType : retourne le type de la case. setPosition (mod\u00e8le : Position) -> None : copie la position fourni dans les coordonnees de la case. setType (mod\u00e8le : CaseType) -> None : copie le type fourni dans le type de la case. __str__ () -> str : m\u00e9thode permettant d'afficher une case comme une cha\u00eene de caract\u00e8res d\u00e9crivant sa position et son type. Exemple d'impl\u00e9mentation d'une carte : from components.case import Case case = Case() print(carte)","title":"Case"},{"location":"DOCS_TECHNICAL/#collider","text":"","title":"Collider"},{"location":"DOCS_TECHNICAL/#cost","text":"","title":"Cost"},{"location":"DOCS_TECHNICAL/#effects","text":"","title":"Effects"},{"location":"DOCS_TECHNICAL/#fly","text":"","title":"Fly"},{"location":"DOCS_TECHNICAL/#health","text":"","title":"Health"},{"location":"DOCS_TECHNICAL/#map","text":"Le composant Map permet de cr\u00e9er des cartes de jeu, repr\u00e9sent\u00e9es par des tables de Case . On peut en cr\u00e9er sans communiquer de param\u00e8tres. Le tableau repr\u00e9sentant le contenu de la carte sera alors initialis\u00e9 comme vide. On peut cependant \u00e9galement cr\u00e9er une carte \u00e0 partir d'une autre (la nouvelle copiera alors le tableau du mod\u00e8le) via la m\u00e9thode initFromModel , ou cr\u00e9er une carte \u00e0 partir d'un tableau (list[list[CaseType]) (la carte utilisera le tableau pour initialiser le sien) via la m\u00e9thode initFromTab . Les propri\u00e9t\u00e9s d'une carte sont : tab (list[list[Case]]) : Le tableau repr\u00e9sentant le contenu de la carte. index (int) : Un index g\u00e9n\u00e9r\u00e9 \u00e0 partir d'un compteur statique, permettant d'identifier la carte. Les d\u00e9tails des propri\u00e9t\u00e9s statiques sont pr\u00e9sent\u00e9s dans le code source, celles-ci \u00e9tant utilis\u00e9es de fa\u00e7on interne. Les m\u00e9thodes d'une carte sont : getTab () -> list[list[Case]] : retourne le tab repr\u00e9sentant le contenu de la carte. getIndex () -> int : retourne l'index de la carte. setTab (mod\u00e8le : list[list[Case]]) -> None : copie le contenu du tableau fourni dans le tab de la carte. changeCase (mod\u00e8le : Case) -> None : remplace la case du tab dont la position est celle du mod\u00e8le par une copie de la case fournie. generate (taille : int) -> None : r\u00e9initialise tab et le remplit d'une carte carr\u00e9e de longueur et largeur \u00e9gale au nombre fourni, g\u00e9n\u00e9r\u00e9e al\u00e9atoirement \u00e0 partir de nombreuses propri\u00e9t\u00e9s internes (voir code source). __str__ () -> str : m\u00e9thode permettant d'afficher une carte comme une cha\u00eene de caract\u00e8res d\u00e9crivant le contenu de son tab. Exemple d'impl\u00e9mentation d'une carte : from core.game.map import Map carte = Map() carte.generate(24) print(carte)","title":"Map"},{"location":"DOCS_TECHNICAL/#money","text":"","title":"Money"},{"location":"DOCS_TECHNICAL/#position","text":"","title":"Position"},{"location":"DOCS_TECHNICAL/#selection","text":"","title":"Selection"},{"location":"DOCS_TECHNICAL/#sprite","text":"Le component Sprite permet d'ajouter un sprite \u00e0 une entit\u00e9. Voir Animer une entit\u00e9 Les param\u00e8tres \u00e0 fournir sont : sprite_sheet (str) : La feuille de sprite \u00e0 utiliser pour l'animation. width (int) : La largeur des frames sur la feuille de sprite. height (int) : La hauteur des frames sur la feuille de sprite. animations (dict) : Le d\u00e9tail des animations (voir ci-dessous). frame_duration (float) : La dur\u00e9e en secondes d'une frame. spritesheet_direction (Orientation) : Orientation des frames dans la feuille (HORIZONTAL ou VERTICAL). D\u00e9faut = HORIZONTAL . default_animation (Animation) : L'animation par d\u00e9faut de l'entit\u00e9. D\u00e9faut = IDLE . default_direction (Direction) : La direction par d\u00e9faut de l'entit\u00e9. D\u00e9faut = DOWN . Le param\u00e8tre animations est un dictionnaire qui associe pour chaque type d'animation et pour chaque direction, une liste d'entiers correspondant aux indices des frames sur la feuille de sprite (la premi\u00e8re frame = 0). Exemple de param\u00e8tre animation: { Animation.IDLE: { Direction.DOWN: [1, 5], Direction.UP: [3, 7], Direction.LEFT: [2, 6], Direction.RIGHT: [0, 4], }, Animation.WALK: { Direction.DOWN: [1, 10, 1, 11], Direction.UP: [3, 14, 3, 15], Direction.LEFT: [2, 12, 2, 13], Direction.RIGHT: [0, 8, 0, 9], }, }","title":"Sprite"},{"location":"DOCS_TECHNICAL/#squad","text":"","title":"Squad"},{"location":"DOCS_TECHNICAL/#stats","text":"","title":"Stats"},{"location":"DOCS_TECHNICAL/#structure","text":"","title":"Structure"},{"location":"DOCS_TECHNICAL/#target","text":"","title":"Target"},{"location":"DOCS_TECHNICAL/#team","text":"","title":"Team"},{"location":"DOCS_TECHNICAL/#velocity","text":"","title":"Velocity"},{"location":"DOCS_TECHNICAL/#systemes","text":"...","title":"Syst\u00e8mes"},{"location":"DOCS_TECHNICAL/#rendersystem","text":"RenderSystem est une classe qui g\u00e8re de fa\u00e7on globale l'affichage. Elle h\u00e9rite de IteratingProcessor ce qui permet d'effectuer des actions sur chaque entit\u00e9s poss\u00e9dant un composant Position et Sprite . Avant l'ex\u00e9cution du process_entity , les entit\u00e9s sont tri\u00e9s par Layer d\u00e9finie par la propri\u00e9t\u00e9 priority de Sprite Son process_entity va afficher les entit\u00e9s concern\u00e9es et \u00e9galement mettre \u00e0 jour l'animation. Lorsque le type d'animation ne vaut pas None , l'entit\u00e9 est consid\u00e9r\u00e9 comme un personnage jouable. Dans ce cas, une barre de vie lui ai ajout\u00e9 au dessus du sprite ainsi qu'un point avec une couleur r\u00e9pr\u00e9sentant son \u00e9quipe et son \u00e9tat de s\u00e9lection. A sa cr\u00e9ation RenderSystem a besoin des 3 \u00e9l\u00e9ments suivants : - une Surface issue de pygame - une Map - un dictionnaire de sprite pour les cases : dict[CaseType,pygame.Surface] M\u00e9thodes : - show_map : affiche la carte (carte d\u00e9finie \u00e0 l'instanciation) - animate_move : m\u00e9thode qui passe les animations de sprite des entit\u00e9s fournit par EventMoveTo - draw_surface : Dessine une surface pygame sur le screen du RenderSystem - draw_rect : Dessine une surface pygame sur le screen du RenderSystem - draw_polygon : Dessine une surface pygame sur le screen du RenderSystem","title":"RenderSystem"}]}