{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"title: \"Pr\u00e9sentation du jeu\" layout: default <<<<<<< HEAD ======= \u2694\ufe0f Clash of piglin Un RTS inspir\u00e9 du Nether de Minecraft IA_VANDENKOORNHUYSE Clash of Piglin Un RTS inspir\u00e9 du Nether de Minecraft Introduction Bienvenue dans Clash of piglin , un jeu de strat\u00e9gie en temps r\u00e9el o\u00f9 deux arm\u00e9es s\u2019affrontent dans les profondeurs du Nether. Chaque joueur doit g\u00e9rer son arm\u00e9e de Piglins et de Ghasts pour an\u00e9antir le bastion ennemi situ\u00e9 \u00e0 l\u2019extr\u00e9mit\u00e9 oppos\u00e9e de la carte. Le jeu combine gestion tactique , contr\u00f4le direct des unit\u00e9s et progression \u00e9conomique . Votre r\u00e9ussite d\u00e9pendra de votre sens de la strat\u00e9gie et de votre capacit\u00e9 \u00e0 exploiter les particularit\u00e9s du terrain du Nether. Objectif D\u00e9truisez le bastion ennemi avant que le v\u00f4tre ne tombe. Chaque joueur d\u00e9fend un bastion : - Si votre bastion est d\u00e9truit \u2192 vous perdez. - Si vous d\u00e9truisez celui de l\u2019adversaire \u2192 vous remportez la partie. Interface du jeu L\u2019interface de Clash of piglin est divis\u00e9e en plusieurs sections : Zone Description Zone centrale Champ de bataille o\u00f9 \u00e9voluent vos troupes Barre lat\u00e9rale gauche Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 1 Barre lat\u00e9rale droite Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 2 Timer Indique le temps depuis le d\u00e9but de la partie <<<<<<< HEAD Ressources ======= \ud83e\ude99 Ressources IA_VANDENKOORNHUYSE La g\u00e9n\u00e9ration d\u2019or augmente automatiquement en fonction de la dur\u00e9e de la partie : Temps \u00e9coul\u00e9 (minutes) Revenu par seconde 0:00 \u2192 1:00 +0.13 1:00 \u2192 2:00 +0.16 2:00 \u2192 3:00 +0.20 3:00 \u2192 4:00 +0.25 4:00 +0.30 <<<<<<< HEAD Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire. \ud83d\udca1 Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire. IA_VANDENKOORNHUYSE Vous pourrez obtenir sur les unit\u00e9s adverses vaincus des r\u00e9compenses correspondant \u00e0 10% du co\u00fbt de l'unit\u00e9. Les unit\u00e9s Unit\u00e9 Image Type Cibles R\u00f4le principal <<<<<<< HEAD Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies ======= Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies >>>>>>> IA_VANDENKOORNHUYSE D\u00e9tails des unit\u00e9s <<<<<<< HEAD Piglin Brute ======= \ud83e\ude93 Piglin Brute IA_VANDENKOORNHUYSE - Forces : Grande r\u00e9sistance, d\u00e9g\u00e2ts \u00e9lev\u00e9s au corps \u00e0 corps, rapide - Faiblesses : Incapable de toucher les unit\u00e9s a\u00e9riennes, limit\u00e9 au corps-\u00e0-corps - Co\u00fbt : 350 or - Vitesse : rapide - R\u00f4le : Encaisser les d\u00e9g\u00e2ts et prot\u00e9ger les unit\u00e9s \u00e0 distance <<<<<<< HEAD Piglin Arbal\u00e9trier ======= \ud83c\udff9 Piglin Arbal\u00e9trier IA_VANDENKOORNHUYSE - Forces : Polyvalent, port\u00e9e moyenne - Faiblesses : Faible d\u00e9fense, DPS moyen - Co\u00fbt : 425 or - Vitesse : moyenne - R\u00f4le : Soutenir les Brutes et contrer les Ghasts <<<<<<< HEAD Ghast ======= \ud83d\udc41\ufe0f Ghast IA_VANDENKOORNHUYSE - Forces : Vole, bonne port\u00e9e, d\u00e9gats \u00e9lev\u00e9s, cible directement les b\u00e2timents - Faiblesses : Incapable de se d\u00e9fendre, faible vitesse d'attaque - Co\u00fbt : 820 or - Vitesse : moyenne - R\u00f4le : D\u00e9truire les b\u00e2timents et assi\u00e9ger le bastion adverse Commandes Action Commande S\u00e9lectionner une unit\u00e9 Clic gauche S\u00e9lection multiple Maintenir clic gauche et glisser D\u00e9placer les troupes Clic droit sur la carte Changer de joueur Ctrl D\u00e9placer la cam\u00e9ra Fl\u00e8ches directionnelles Zoom / D\u00e9zoom Molette de la souris <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Astuce : Vous pouvez combiner clic gauche + molette pour ajuster rapidement votre zone de contr\u00f4le. Interface d\u2019achat <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Chaque c\u00f4t\u00e9 de l\u2019\u00e9cran affiche une interface d\u2019achat : - Liste des unit\u00e9s disponibles avec leur co\u00fbt. - Solde actuel d\u2019or . - Barre de vie du bastion . Cliquez sur une unit\u00e9 pour la recruter imm\u00e9diatement , selon vos ressources disponibles. Les troupes apparaissent \u00e0 proximit\u00e9 de votre bastion. Terrain et effets Le champ de bataille du Nether influence vos unit\u00e9s : Type de terrain Apparence Effet principal <<<<<<< HEAD Netherrack Terrain neutre Blue Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) Red Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) Soul Sand Ralentit les unit\u00e9s terrestres Lava Infranchissable par les unit\u00e9s terrestres > Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain. | Netherrack | | Terrain neutre | | Blue Netherrack | | Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) | | Red Netherrack | | Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) | | Soul Sand | | Ralentit les unit\u00e9s terrestres | | Lava | | Infranchissable par les unit\u00e9s terrestres | \ud83d\udca1 Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain. IA_VANDENKOORNHUYSE D\u00e9roulement d\u2019une partie Chaque joueur d\u00e9marre avec un bastion et un revenu initial. Achetez vos premi\u00e8res unit\u00e9s via l\u2019interface lat\u00e9rale. D\u00e9ployez-les et positionnez-les strat\u00e9giquement. Les revenus augmentent au fil du temps, permettant plus d\u2019unit\u00e9s. La bataille continue jusqu\u2019\u00e0 la destruction d\u2019un des bastions. <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Conseils strat\u00e9giques <<<<<<< HEAD - Prot\u00e9gez votre bastion avec un mur de Piglins Brute. - Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. - Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. - Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. - Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille. ======= - \ud83e\uddf1 Prot\u00e9gez votre bastion avec un mur de Piglins Brute. - \ud83c\udff9 Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. - \ud83d\udc41\ufe0f Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. - \ud83d\udcb0 Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. - \u26a1 Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille. IA_VANDENKOORNHUYSE Fin de partie La partie se termine lorsque : - La vie d\u2019un bastion tombe \u00e0 z\u00e9ro. - Le joueur adverse est d\u00e9clar\u00e9 vainqueur . <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Cr\u00e9dits Clash of Piglin est un projet de d\u00e9veloppement ind\u00e9pendant inspir\u00e9 de l\u2019univers de Minecraft (\u00a9 Mojang Studios). Con\u00e7u et programm\u00e9 par Mallevaey Adrien, Vandenkoornhuyse Lorenzo, Ciolkowski Yann, Pruvost Scotty, Vandewalle J\u00e9rome et Pinceel Matthieu. <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE","title":"Home"},{"location":"#clash-of-piglin","text":"","title":"\u2694\ufe0f Clash of piglin"},{"location":"#un-rts-inspire-du-nether-de-minecraft","text":"IA_VANDENKOORNHUYSE","title":"Un RTS inspir\u00e9 du Nether de Minecraft"},{"location":"#un-rts-inspire-du-nether-de-minecraft_1","text":"","title":"Un RTS inspir\u00e9 du Nether de Minecraft"},{"location":"#introduction","text":"Bienvenue dans Clash of piglin , un jeu de strat\u00e9gie en temps r\u00e9el o\u00f9 deux arm\u00e9es s\u2019affrontent dans les profondeurs du Nether. Chaque joueur doit g\u00e9rer son arm\u00e9e de Piglins et de Ghasts pour an\u00e9antir le bastion ennemi situ\u00e9 \u00e0 l\u2019extr\u00e9mit\u00e9 oppos\u00e9e de la carte. Le jeu combine gestion tactique , contr\u00f4le direct des unit\u00e9s et progression \u00e9conomique . Votre r\u00e9ussite d\u00e9pendra de votre sens de la strat\u00e9gie et de votre capacit\u00e9 \u00e0 exploiter les particularit\u00e9s du terrain du Nether.","title":"Introduction"},{"location":"#objectif","text":"D\u00e9truisez le bastion ennemi avant que le v\u00f4tre ne tombe. Chaque joueur d\u00e9fend un bastion : - Si votre bastion est d\u00e9truit \u2192 vous perdez. - Si vous d\u00e9truisez celui de l\u2019adversaire \u2192 vous remportez la partie.","title":"Objectif"},{"location":"#interface-du-jeu","text":"L\u2019interface de Clash of piglin est divis\u00e9e en plusieurs sections : Zone Description Zone centrale Champ de bataille o\u00f9 \u00e9voluent vos troupes Barre lat\u00e9rale gauche Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 1 Barre lat\u00e9rale droite Indique vos ressources et la vie de votre bastion et permet l'achat des unit\u00e9s pour le joueur 2 Timer Indique le temps depuis le d\u00e9but de la partie <<<<<<< HEAD","title":"Interface du jeu"},{"location":"#ressources","text":"=======","title":"Ressources"},{"location":"#ressources_1","text":"IA_VANDENKOORNHUYSE La g\u00e9n\u00e9ration d\u2019or augmente automatiquement en fonction de la dur\u00e9e de la partie : Temps \u00e9coul\u00e9 (minutes) Revenu par seconde 0:00 \u2192 1:00 +0.13 1:00 \u2192 2:00 +0.16 2:00 \u2192 3:00 +0.20 3:00 \u2192 4:00 +0.25 4:00 +0.30 <<<<<<< HEAD","title":"\ud83e\ude99 Ressources"},{"location":"#basez-une-strategie-basee-sur-la-quantite-dor-que-vous-possedez-economiser-de-lor-sera-parfois-la-meilleure-chose-a-faire","text":"\ud83d\udca1 Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire. IA_VANDENKOORNHUYSE Vous pourrez obtenir sur les unit\u00e9s adverses vaincus des r\u00e9compenses correspondant \u00e0 10% du co\u00fbt de l'unit\u00e9.","title":"Basez une strat\u00e9gie bas\u00e9e sur la quantit\u00e9 d'or que vous poss\u00e9dez. \u00c9conomiser de l'or sera parfois la meilleure chose \u00e0 faire."},{"location":"#les-unites","text":"Unit\u00e9 Image Type Cibles R\u00f4le principal <<<<<<< HEAD Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies ======= Piglin Brute Corps \u00e0 corps Troupes terrestres Attaquant puissant de premi\u00e8re ligne Piglin Arbal\u00e9trier Distance Troupes terrestres et a\u00e9riennes Soutien \u00e0 moyenne port\u00e9e Ghast A\u00e9rien B\u00e2timents uniquement Bombardement des structures ennemies >>>>>>> IA_VANDENKOORNHUYSE","title":"Les unit\u00e9s"},{"location":"#details-des-unites","text":"<<<<<<< HEAD","title":"D\u00e9tails des unit\u00e9s"},{"location":"#piglin-brute","text":"=======","title":"Piglin Brute"},{"location":"#piglin-brute_1","text":"IA_VANDENKOORNHUYSE - Forces : Grande r\u00e9sistance, d\u00e9g\u00e2ts \u00e9lev\u00e9s au corps \u00e0 corps, rapide - Faiblesses : Incapable de toucher les unit\u00e9s a\u00e9riennes, limit\u00e9 au corps-\u00e0-corps - Co\u00fbt : 350 or - Vitesse : rapide - R\u00f4le : Encaisser les d\u00e9g\u00e2ts et prot\u00e9ger les unit\u00e9s \u00e0 distance <<<<<<< HEAD","title":"\ud83e\ude93 Piglin Brute"},{"location":"#piglin-arbaletrier","text":"=======","title":"Piglin Arbal\u00e9trier"},{"location":"#piglin-arbaletrier_1","text":"IA_VANDENKOORNHUYSE - Forces : Polyvalent, port\u00e9e moyenne - Faiblesses : Faible d\u00e9fense, DPS moyen - Co\u00fbt : 425 or - Vitesse : moyenne - R\u00f4le : Soutenir les Brutes et contrer les Ghasts <<<<<<< HEAD","title":"\ud83c\udff9 Piglin Arbal\u00e9trier"},{"location":"#ghast","text":"=======","title":"Ghast"},{"location":"#ghast_1","text":"IA_VANDENKOORNHUYSE - Forces : Vole, bonne port\u00e9e, d\u00e9gats \u00e9lev\u00e9s, cible directement les b\u00e2timents - Faiblesses : Incapable de se d\u00e9fendre, faible vitesse d'attaque - Co\u00fbt : 820 or - Vitesse : moyenne - R\u00f4le : D\u00e9truire les b\u00e2timents et assi\u00e9ger le bastion adverse","title":"\ud83d\udc41\ufe0f Ghast"},{"location":"#commandes","text":"Action Commande S\u00e9lectionner une unit\u00e9 Clic gauche S\u00e9lection multiple Maintenir clic gauche et glisser D\u00e9placer les troupes Clic droit sur la carte Changer de joueur Ctrl D\u00e9placer la cam\u00e9ra Fl\u00e8ches directionnelles Zoom / D\u00e9zoom Molette de la souris <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Astuce : Vous pouvez combiner clic gauche + molette pour ajuster rapidement votre zone de contr\u00f4le.","title":"Commandes"},{"location":"#interface-dachat","text":"<<<<<<< HEAD ======= IA_VANDENKOORNHUYSE Chaque c\u00f4t\u00e9 de l\u2019\u00e9cran affiche une interface d\u2019achat : - Liste des unit\u00e9s disponibles avec leur co\u00fbt. - Solde actuel d\u2019or . - Barre de vie du bastion . Cliquez sur une unit\u00e9 pour la recruter imm\u00e9diatement , selon vos ressources disponibles. Les troupes apparaissent \u00e0 proximit\u00e9 de votre bastion.","title":"Interface d\u2019achat"},{"location":"#terrain-et-effets","text":"Le champ de bataille du Nether influence vos unit\u00e9s : Type de terrain Apparence Effet principal <<<<<<< HEAD Netherrack Terrain neutre Blue Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) Red Netherrack Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) Soul Sand Ralentit les unit\u00e9s terrestres Lava Infranchissable par les unit\u00e9s terrestres","title":"Terrain et effets"},{"location":"#les-unites-volantes-ne-sont-pas-affectees-par-le-terrain","text":"| Netherrack | | Terrain neutre | | Blue Netherrack | | Terrain d\u00e9coratif (pr\u00e9sent sous votre bastion) | | Red Netherrack | | Terrain d\u00e9coratif (pr\u00e9sent sous le bastion adverse) | | Soul Sand | | Ralentit les unit\u00e9s terrestres | | Lava | | Infranchissable par les unit\u00e9s terrestres | \ud83d\udca1 Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain. IA_VANDENKOORNHUYSE","title":"&gt; Les unit\u00e9s volantes ne sont pas affect\u00e9es par le terrain."},{"location":"#deroulement-dune-partie","text":"Chaque joueur d\u00e9marre avec un bastion et un revenu initial. Achetez vos premi\u00e8res unit\u00e9s via l\u2019interface lat\u00e9rale. D\u00e9ployez-les et positionnez-les strat\u00e9giquement. Les revenus augmentent au fil du temps, permettant plus d\u2019unit\u00e9s. La bataille continue jusqu\u2019\u00e0 la destruction d\u2019un des bastions. <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE","title":"D\u00e9roulement d\u2019une partie"},{"location":"#conseils-strategiques","text":"<<<<<<< HEAD - Prot\u00e9gez votre bastion avec un mur de Piglins Brute. - Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. - Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. - Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. - Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille. ======= - \ud83e\uddf1 Prot\u00e9gez votre bastion avec un mur de Piglins Brute. - \ud83c\udff9 Placez vos arbal\u00e9triers l\u00e9g\u00e8rement en retrait. - \ud83d\udc41\ufe0f Envoyez les Ghasts sur les b\u00e2timents pendant que vos unit\u00e9s au sol occupent l\u2019ennemi. - \ud83d\udcb0 Surveillez vos ressources : un bon rythme d\u2019achat garantit la sup\u00e9riorit\u00e9 num\u00e9rique. - \u26a1 Ne restez pas statique ! D\u00e9placez vos troupes selon la situation du champ de bataille. IA_VANDENKOORNHUYSE","title":"Conseils strat\u00e9giques"},{"location":"#fin-de-partie","text":"La partie se termine lorsque : - La vie d\u2019un bastion tombe \u00e0 z\u00e9ro. - Le joueur adverse est d\u00e9clar\u00e9 vainqueur . <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE","title":"Fin de partie"},{"location":"#credits","text":"Clash of Piglin est un projet de d\u00e9veloppement ind\u00e9pendant inspir\u00e9 de l\u2019univers de Minecraft (\u00a9 Mojang Studios). Con\u00e7u et programm\u00e9 par Mallevaey Adrien, Vandenkoornhuyse Lorenzo, Ciolkowski Yann, Pruvost Scotty, Vandewalle J\u00e9rome et Pinceel Matthieu. <<<<<<< HEAD ======= IA_VANDENKOORNHUYSE","title":"Cr\u00e9dits"},{"location":"ADMIN_DOCS/","text":"Documentation Technique \u2013 Clash of Piglin Table des mati\u00e8res Informations g\u00e9n\u00e9rales Objet du document R\u00e9f\u00e9rences normatives Vue d\u2019ensemble du jeu Environnement logiciel requis Proc\u00e9dure d\u2019installation Exploitation du jeu Structure du code source Fichiers de donn\u00e9es S\u00e9curit\u00e9 et int\u00e9grit\u00e9 Maintenance et mise \u00e0 jour Erreurs courantes et solutions Glossaire Support et contact 1. Informations g\u00e9n\u00e9rales \u00c9l\u00e9ment D\u00e9tail Titre Documentation Techinque - Clash of piglin Version 1.0 Auteur Zwartkat Date de r\u00e9vision 18/10/2025 R\u00e9f\u00e9rence du document DOC-GD-TECH-001 Public cible D\u00e9veloppeurs, testeurs, int\u00e9grateurs Langage Python 3.11+ Biblioth\u00e8ques principales Pygame 2.6, esper 2. Objet du document Ce document d\u00e9crit l\u2019 architecture logicielle , les modules , la proc\u00e9dure d\u2019installation , les configurations , et la structure du code du jeu Clash of piglin . L\u2019objectif est de permettre \u00e0 tout d\u00e9veloppeur de comprendre le fonctionnement interne du jeu, de le modifier ou de le maintenir. 3. R\u00e9f\u00e9rences normatives ISO/IEC/IEEE 26514:2008 \u2014 Design and development of information for users Documentation Pygame Python 3.11 4. Vue d\u2019ensemble du jeu Clash of piglin est un jeu type RTS inspir\u00e9 de Minecraft Deux joueurs s'affrontent dans l'objectif de d\u00e9truire le bastion de l'adversaire. Fonctionnalit\u00e9s principales D\u00e9placement des troupes Achat de troupes Syst\u00e8me de g\u00e9n\u00e9ration d'argent automatique Interface graphique simple avec menus. 5. Environnement logiciel requis Composant Sp\u00e9cification Syst\u00e8me d\u2019exploitation Windows 7 ou sup\u00e9rieur, macOS 10.12 ou sup\u00e9rieur, Linux r\u00e9cent M\u00e9moire vive (RAM) 2 Go Stockage 50 Mo d\u2019espace libre Python 3.11 ou sup\u00e9rieur Biblioth\u00e8ques Pygame 2.6, autres d\u00e9pendances via requirements.txt R\u00e9solution d\u2019\u00e9cran 800x600 minimum 6. Proc\u00e9dure d\u2019installation 6.1. Cloner le d\u00e9p\u00f4t git clone https://github.com/Zwartkat/Clash-of-Piglin cd Clash-of-Piglin 6.2. Installer les d\u00e9pendances pip install -r requirements.txt 6.3. Lancer le jeu python ./src/main.py 7. Exploitation du jeu Cette section d\u00e9crit comment d\u00e9marrer, arr\u00eater le jeu Clash of Piglin. 7.1 D\u00e9marrage du jeu Assurez-vous que toutes les d\u00e9pendances sont install\u00e9es : pip install -r requirements.txt Lancer le jeu depuis le r\u00e9pertoire src/ : python main.py Le menu principal appara\u00eet et vous pouvez : D\u00e9marrer une partie Consulter les cr\u00e9dits Quitter 7.2 Arr\u00eat du jeu Le jeu peut \u00eatre arr\u00eat\u00e9 via : Le menu principal \u2192 Quitter Echap \u00e0 la fin de partie La fermeture de la fen\u00eatre (non recommand\u00e9) 8. Structure du code source src/ \u2502 \u2502\u2500\u2500 main.py # Point d\u2019entr\u00e9e principal du jeu \u2502 \u251c\u2500\u2500 components/ # Composants du syst\u00e8me ECS \u2502 \u251c\u2500\u2500 base/ # Composants de base : sant\u00e9, position, \u00e9quipe, etc. \u2502 \u251c\u2500\u2500 gameplay/ # Composants li\u00e9s aux m\u00e9caniques de jeu (attaque, s\u00e9lection) \u2502 \u2514\u2500\u2500 rendering/ # Composants graphiques (sprites, visuels) \u2502 \u251c\u2500\u2500 config/ # Configuration du jeu (unit\u00e9s, terrains, couches) \u2502 \u251c\u2500\u2500 layer.py # D\u00e9finit les couches d\u2019affichage \u2502 \u251c\u2500\u2500 terrains.py # D\u00e9finit les types de terrains \u2502 \u2514\u2500\u2500 units.py # D\u00e9finit les caract\u00e9ristiques des unit\u00e9s \u2502 \u251c\u2500\u2500 core/ # Noyau du moteur de jeu \u2502 \u251c\u2500\u2500 config.py # Gestion globale de la configuration \u2502 \u251c\u2500\u2500 engine.py # Boucle principale du moteur de jeu \u2502 \u251c\u2500\u2500 services.py # Gestion des services internes (event bus, gestion de joueur, etc.) \u2502 \u2502 \u2502 \u251c\u2500\u2500 ecs/ # Syst\u00e8me ECS (Entity-Component-System) \u2502 \u2502 \u251c\u2500\u2500 component.py # Classe abstraite repr\u00e9sentant un composant \u2502 \u2502 \u251c\u2500\u2500 entity.py # Classe abstraite repr\u00e9sentant une entit\u00e9 \u2502 \u2502 \u251c\u2500\u2500 event.py # Classe abstraite repr\u00e9sentant un \u00e9v\u00e9nement \u2502 \u2502 \u251c\u2500\u2500 event_bus.py # Bus d\u2019\u00e9v\u00e9nements centralis\u00e9 \u2502 \u2502 \u2514\u2500\u2500 iterator_system.py # Gestion des it\u00e9ratives des entit\u00e9s dans le moteur ECS \u2502 \u2502 \u2502 \u251c\u2500\u2500 game/ # Gestion du monde et des entit\u00e9s de jeu \u2502 \u2502 \u251c\u2500\u2500 camera.py # Gestion de la cam\u00e9ra \u2502 \u2502 \u251c\u2500\u2500 map.py # Gestion de la carte \u2502 \u2502 \u251c\u2500\u2500 player.py # D\u00e9finition du joueur \u2502 \u2502 \u251c\u2500\u2500 player_manager.py # Gestion multi-joueur / joueurs IA \u2502 \u2502 \u2514\u2500\u2500 terrain.py # Gestion des terrains du jeu \u2502 \u2502 \u2502 \u2514\u2500\u2500 input/ # Gestion des entr\u00e9es utilisateur \u2502 \u2514\u2500\u2500 input_manager.py # Mappage clavier/souris et actions \u2502 \u251c\u2500\u2500 enums/ # D\u00e9clarations d\u2019\u00e9num\u00e9rations globales \u2502 \u251c\u2500\u2500 case_type.py # Types de cases \u2502 \u251c\u2500\u2500 input_actions.py # Actions d\u2019entr\u00e9e (clic, fl\u00e8ches, etc.) \u2502 \u251c\u2500\u2500 source_effect.py # Origine des effets (terrain, balise, etc.) \u2502 \u2502 \u2502 \u2514\u2500\u2500 entity/ # Enums li\u00e9es aux entit\u00e9s \u2502 \u251c\u2500\u2500 events/ # \u00c9v\u00e9nements ECS (communication entre syst\u00e8mes) \u2502 \u251c\u2500\u2500 attack_event.py # \u00c9v\u00e9nement d\u2019attaque \u2502 \u251c\u2500\u2500 move_order_event.py # Ordre de mouvement \u2502 \u251c\u2500\u2500 select_event.py # S\u00e9lection d\u2019unit\u00e9 \u2502 \u251c\u2500\u2500 spawn_unit_event.py # Apparition d\u2019unit\u00e9 \u2502 \u251c\u2500\u2500 death_event.py # Mort d\u2019une entit\u00e9 \u2502 \u251c\u2500\u2500 victory_event.py # Condition de victoire \u2502 \u2514\u2500\u2500 ... # (autres \u00e9v\u00e9nements cam\u00e9ra, zoom, etc.) \u2502 \u251c\u2500\u2500 factories/ # Cr\u00e9ation d\u2019entit\u00e9s et d\u2019unit\u00e9s \u2502 \u251c\u2500\u2500 entity_factory.py # Fabrique d\u2019entit\u00e9s g\u00e9n\u00e9riques \u2502 \u2514\u2500\u2500 unit_factory.py # Fabrique d\u2019unit\u00e9s sp\u00e9cifiques (charg\u00e9es depuis la configuration) \u2502 \u251c\u2500\u2500 systems/ # Syst\u00e8mes ECS (logique du jeu) \u2502 \u251c\u2500\u2500 combat/ # Syst\u00e8mes de combat (fl\u00e8ches, cibles, troupes) \u2502 \u251c\u2500\u2500 input/ # Syst\u00e8mes li\u00e9s aux entr\u00e9es et cam\u00e9ra \u2502 \u251c\u2500\u2500 rendering/ # Syst\u00e8mes d\u2019affichage et HUD \u2502 \u251c\u2500\u2500 world/ # Syst\u00e8mes du monde (\u00e9conomie, mouvement, collisions) \u2502 \u251c\u2500\u2500 death_event_handler.py # Gestion de la mort des entit\u00e9s \u2502 \u251c\u2500\u2500 quit_system.py # Fermeture propre du jeu \u2502 \u2514\u2500\u2500 victory_system.py # Gestion des conditions de victoire \u2502 \u2514\u2500\u2500 ui/ # Interface utilisateur \u2502 \u2514\u2500\u2500 hud.py # Affichage du HUD (interface de jeu) 8.1 Description des modules principaux Module R\u00f4le et responsabilit\u00e9s main.py Point d\u2019entr\u00e9e du jeu. Initialise le moteur, charge la configuration et lance la boucle principale. Ouvre le menu principal du jeu. core/ Contient le moteur principal et les services. Gestion de la boucle de jeu, des entit\u00e9s, \u00e9v\u00e9nements et entr\u00e9es. core/ecs/ Impl\u00e9mente le pattern ECS : d\u00e9finition des entit\u00e9s, composants, syst\u00e8mes et bus d\u2019\u00e9v\u00e9nements. components/ D\u00e9finit les composants r\u00e9utilisables : sant\u00e9, position, attaque, etc. systems/ Contient la logique du jeu par syst\u00e8me : combat, mouvement, rendu, \u00e9conomie, input, etc. Chaque syst\u00e8me manipule les entit\u00e9s via leurs composants. config/ Fichiers de configuration : unit\u00e9s, terrains, couches de rendu. Permet de modifier les param\u00e8tres du jeu sans changer le code. enums/ D\u00e9clarations d\u2019\u00e9num\u00e9rations globales pour types d\u2019entit\u00e9s, actions, effets et cases. events/ \u00c9v\u00e9nements ECS pour la communication entre syst\u00e8mes (attaques, mouvements, s\u00e9lections, victoire, mort). factories/ Cr\u00e9ation et initialisation des entit\u00e9s \u00e0 partir des composants et des fichiers de configuration. ui/ Gestion du HUD et de l\u2019interface utilisateur. Affiche les informations du joueur et l\u2019\u00e9tat du jeu. Permet au joueur de voir et d'int\u00e9ragir avec le jeu. 9. Fichiers de donn\u00e9es Le jeu utilise plusieurs types de fichiers de donn\u00e9es externes : Dossier / Fichier R\u00f4le Format / Contenu config/layer.py D\u00e9finit les couches d\u2019affichage du moteur (priorit\u00e9 de rendu). Script Python config/terrains.py Sp\u00e9cifie les types de terrains et leurs effets sur les unit\u00e9s. Script Python config/units.py D\u00e9finit les caract\u00e9ristiques de chaque unit\u00e9 (PV, attaque, port\u00e9e, co\u00fbt). Script Python assets/ Contient les ressources graphiques et audio du jeu. Images et sons config.yaml Contient les configurations g\u00e9n\u00e9rales et les textes Donn\u00e9es au format YAML 10. S\u00e9curit\u00e9 et int\u00e9grit\u00e9 Le jeu applique plusieurs m\u00e9canismes pour assurer la s\u00e9curit\u00e9 et l\u2019int\u00e9grit\u00e9 des donn\u00e9es : Validation des entr\u00e9es utilisateur Toutes les entr\u00e9es sont contr\u00f4l\u00e9es avant traitement (clavier, souris, s\u00e9lection d\u2019unit\u00e9) pour \u00e9viter les \u00e9tats invalides. Int\u00e9grit\u00e9 des fichiers de configuration et ressources Les fichiers de /config/ et /assets/ sont v\u00e9rifi\u00e9s au lancement pour garantir qu\u2019ils sont complets et coh\u00e9rents. Int\u00e9grit\u00e9 des entit\u00e9s et du moteur ECS Les syst\u00e8mes (combat, mouvement, rendu) appliquent des contraintes pour \u00e9viter les actions ill\u00e9gales (attaques sur unit\u00e9s mortes, mouvements hors carte). 11. Maintenance et mise \u00e0 jour Mise \u00e0 jour du jeu : Tirer les derni\u00e8res modifications : git pull origin main Ajout de nouvelles entit\u00e9s : Cr\u00e9er le nouveau type d'entit\u00e9 dans enums/entity/entity_type.py Ajouter dans la constante UNITS la cl\u00e9 correspondant \u00e0 l'entit\u00e9 et lui assigner un objet entit\u00e9 contenant les composants correspondants \u00e0 l'entit\u00e9 UNITS = { EntityType.NEW : Entity( components=[ #Liste des composants de l''entit\u00e9 ]) } 12. Erreurs courantes et solutions Erreur Cause possible Solution ModuleNotFoundError: No module named 'pygame' Pygame non install\u00e9 ou mauvaise version Ex\u00e9cuter pip install -r requirements.txt ou v\u00e9rifier la version de Python et Pygame Une unit\u00e9 ne r\u00e9pond pas aux ordres Composants manquants ou mal initialis\u00e9s dans UNITS V\u00e9rifier que tous les composants n\u00e9cessaires sont inclus et correctement import\u00e9s Erreur de chargement d\u2019un fichier de configuration Fichier manquant ou syntaxe invalide dans config/*.py ou config.yaml V\u00e9rifier la pr\u00e9sence du fichier et sa syntaxe. Pour YAML, utiliser un validateur YAML Actions utilisateur non d\u00e9tect\u00e9es (clic, touches) Mauvais mapping clavier/souris ou conflit dans input_manager.py V\u00e9rifier que input_actions.py correspond aux touches utilis\u00e9es et que input_manager est bien initialis\u00e9 Sprites ou ressources graphiques manquants Fichier absent dans assets/ ou chemin incorrect V\u00e9rifier la pr\u00e9sence et le chemin des fichiers images/audio utilis\u00e9s par les composants sprite Probl\u00e8me de cam\u00e9ra Mauvaise r\u00e9cup\u00e9ration de la taille de la fen\u00eatre Redimensionner la fen\u00eatre Impossible de cloner ou pull le d\u00e9p\u00f4t Git Probl\u00e8me de droits ou URL incorrecte V\u00e9rifier l\u2019URL et vos droits Git, utiliser git clone https://github.com/Zwartkat/Clash-of-Piglin 13. Glossaire Terme D\u00e9finition ECS (Entity-Component-System) Architecture logicielle qui s\u00e9pare les entit\u00e9s (objets du jeu), leurs composants (donn\u00e9es) et les syst\u00e8mes (logique de traitement). Entit\u00e9 (Entity) Objet du jeu unique (unit\u00e9, b\u00e2timent, projectile) constitu\u00e9 d\u2019un ou plusieurs composants. Composant (Component) Conteneur de donn\u00e9es d\u2019une entit\u00e9 (ex : sant\u00e9, position, vitesse, attaque). Syst\u00e8me (System) Module qui applique la logique du jeu aux entit\u00e9s selon leurs composants (ex : combat, mouvement, rendu). Event / \u00c9v\u00e9nement Message ou signal envoy\u00e9 entre syst\u00e8mes pour d\u00e9clencher des actions (ex : attaque, d\u00e9placement, mort). Bus d\u2019\u00e9v\u00e9nements (Event Bus) M\u00e9canisme centralis\u00e9 pour diffuser les \u00e9v\u00e9nements aux syst\u00e8mes concern\u00e9s. HUD (Head-Up Display) Interface utilisateur affichant les informations de jeu : ressources, points de vie, s\u00e9lection d\u2019unit\u00e9s. Configuration (Config) Fichiers ou scripts d\u00e9finissant les param\u00e8tres du jeu, comme les unit\u00e9s, terrains et couches de rendu. Assets Ressources graphiques et audio utilis\u00e9es par le jeu (images, sprites, sons). Python Langage de programmation utilis\u00e9 pour d\u00e9velopper le jeu. Pygame Biblioth\u00e8que Python utilis\u00e9e pour g\u00e9rer les graphismes, les entr\u00e9es et le son. Terrain Case ou zone du jeu qui peuvent avoir des propri\u00e9t\u00e9s particuli\u00e8res (effets sur le mouvement, etc.). R\u00e9pertoire racine ( src/ ) Dossier contenant l\u2019ensemble du code source et des modules du jeu. 14. Support et contact Pour tout probl\u00e8me ou question, contacter : Zwartkat, lorenzovdkn, darkell, workai, SparkasselaBank ou MatthieuPinceel en passant par GitHub Issues Lien du d\u00e9p\u00f4t : https://github.com/Zwartkat/Clash-of-Piglin Cette documentation pour Clash of Piglin respecte les pr\u00e9conisations de la norme ISO/IEC/IEEE 26514.","title":"Documentation Technique \u2013 Clash of Piglin"},{"location":"ADMIN_DOCS/#documentation-technique-clash-of-piglin","text":"","title":"Documentation Technique \u2013 Clash of Piglin"},{"location":"ADMIN_DOCS/#table-des-matieres","text":"Informations g\u00e9n\u00e9rales Objet du document R\u00e9f\u00e9rences normatives Vue d\u2019ensemble du jeu Environnement logiciel requis Proc\u00e9dure d\u2019installation Exploitation du jeu Structure du code source Fichiers de donn\u00e9es S\u00e9curit\u00e9 et int\u00e9grit\u00e9 Maintenance et mise \u00e0 jour Erreurs courantes et solutions Glossaire Support et contact","title":"Table des mati\u00e8res"},{"location":"ADMIN_DOCS/#1-informations-generales","text":"\u00c9l\u00e9ment D\u00e9tail Titre Documentation Techinque - Clash of piglin Version 1.0 Auteur Zwartkat Date de r\u00e9vision 18/10/2025 R\u00e9f\u00e9rence du document DOC-GD-TECH-001 Public cible D\u00e9veloppeurs, testeurs, int\u00e9grateurs Langage Python 3.11+ Biblioth\u00e8ques principales Pygame 2.6, esper","title":"1. Informations g\u00e9n\u00e9rales"},{"location":"ADMIN_DOCS/#2-objet-du-document","text":"Ce document d\u00e9crit l\u2019 architecture logicielle , les modules , la proc\u00e9dure d\u2019installation , les configurations , et la structure du code du jeu Clash of piglin . L\u2019objectif est de permettre \u00e0 tout d\u00e9veloppeur de comprendre le fonctionnement interne du jeu, de le modifier ou de le maintenir.","title":"2. Objet du document"},{"location":"ADMIN_DOCS/#3-references-normatives","text":"ISO/IEC/IEEE 26514:2008 \u2014 Design and development of information for users Documentation Pygame Python 3.11","title":"3. R\u00e9f\u00e9rences normatives"},{"location":"ADMIN_DOCS/#4-vue-densemble-du-jeu","text":"Clash of piglin est un jeu type RTS inspir\u00e9 de Minecraft Deux joueurs s'affrontent dans l'objectif de d\u00e9truire le bastion de l'adversaire.","title":"4. Vue d\u2019ensemble du jeu"},{"location":"ADMIN_DOCS/#fonctionnalites-principales","text":"D\u00e9placement des troupes Achat de troupes Syst\u00e8me de g\u00e9n\u00e9ration d'argent automatique Interface graphique simple avec menus.","title":"Fonctionnalit\u00e9s principales"},{"location":"ADMIN_DOCS/#5-environnement-logiciel-requis","text":"Composant Sp\u00e9cification Syst\u00e8me d\u2019exploitation Windows 7 ou sup\u00e9rieur, macOS 10.12 ou sup\u00e9rieur, Linux r\u00e9cent M\u00e9moire vive (RAM) 2 Go Stockage 50 Mo d\u2019espace libre Python 3.11 ou sup\u00e9rieur Biblioth\u00e8ques Pygame 2.6, autres d\u00e9pendances via requirements.txt R\u00e9solution d\u2019\u00e9cran 800x600 minimum","title":"5. Environnement logiciel requis"},{"location":"ADMIN_DOCS/#6-procedure-dinstallation","text":"","title":"6. Proc\u00e9dure d\u2019installation"},{"location":"ADMIN_DOCS/#61-cloner-le-depot","text":"git clone https://github.com/Zwartkat/Clash-of-Piglin cd Clash-of-Piglin","title":"6.1. Cloner le d\u00e9p\u00f4t"},{"location":"ADMIN_DOCS/#62-installer-les-dependances","text":"pip install -r requirements.txt","title":"6.2. Installer les d\u00e9pendances"},{"location":"ADMIN_DOCS/#63-lancer-le-jeu","text":"python ./src/main.py","title":"6.3. Lancer le jeu"},{"location":"ADMIN_DOCS/#7-exploitation-du-jeu","text":"Cette section d\u00e9crit comment d\u00e9marrer, arr\u00eater le jeu Clash of Piglin.","title":"7. Exploitation du jeu"},{"location":"ADMIN_DOCS/#71-demarrage-du-jeu","text":"Assurez-vous que toutes les d\u00e9pendances sont install\u00e9es : pip install -r requirements.txt Lancer le jeu depuis le r\u00e9pertoire src/ : python main.py Le menu principal appara\u00eet et vous pouvez : D\u00e9marrer une partie Consulter les cr\u00e9dits Quitter","title":"7.1 D\u00e9marrage du jeu"},{"location":"ADMIN_DOCS/#72-arret-du-jeu","text":"Le jeu peut \u00eatre arr\u00eat\u00e9 via : Le menu principal \u2192 Quitter Echap \u00e0 la fin de partie La fermeture de la fen\u00eatre (non recommand\u00e9)","title":"7.2 Arr\u00eat du jeu"},{"location":"ADMIN_DOCS/#8-structure-du-code-source","text":"src/ \u2502 \u2502\u2500\u2500 main.py # Point d\u2019entr\u00e9e principal du jeu \u2502 \u251c\u2500\u2500 components/ # Composants du syst\u00e8me ECS \u2502 \u251c\u2500\u2500 base/ # Composants de base : sant\u00e9, position, \u00e9quipe, etc. \u2502 \u251c\u2500\u2500 gameplay/ # Composants li\u00e9s aux m\u00e9caniques de jeu (attaque, s\u00e9lection) \u2502 \u2514\u2500\u2500 rendering/ # Composants graphiques (sprites, visuels) \u2502 \u251c\u2500\u2500 config/ # Configuration du jeu (unit\u00e9s, terrains, couches) \u2502 \u251c\u2500\u2500 layer.py # D\u00e9finit les couches d\u2019affichage \u2502 \u251c\u2500\u2500 terrains.py # D\u00e9finit les types de terrains \u2502 \u2514\u2500\u2500 units.py # D\u00e9finit les caract\u00e9ristiques des unit\u00e9s \u2502 \u251c\u2500\u2500 core/ # Noyau du moteur de jeu \u2502 \u251c\u2500\u2500 config.py # Gestion globale de la configuration \u2502 \u251c\u2500\u2500 engine.py # Boucle principale du moteur de jeu \u2502 \u251c\u2500\u2500 services.py # Gestion des services internes (event bus, gestion de joueur, etc.) \u2502 \u2502 \u2502 \u251c\u2500\u2500 ecs/ # Syst\u00e8me ECS (Entity-Component-System) \u2502 \u2502 \u251c\u2500\u2500 component.py # Classe abstraite repr\u00e9sentant un composant \u2502 \u2502 \u251c\u2500\u2500 entity.py # Classe abstraite repr\u00e9sentant une entit\u00e9 \u2502 \u2502 \u251c\u2500\u2500 event.py # Classe abstraite repr\u00e9sentant un \u00e9v\u00e9nement \u2502 \u2502 \u251c\u2500\u2500 event_bus.py # Bus d\u2019\u00e9v\u00e9nements centralis\u00e9 \u2502 \u2502 \u2514\u2500\u2500 iterator_system.py # Gestion des it\u00e9ratives des entit\u00e9s dans le moteur ECS \u2502 \u2502 \u2502 \u251c\u2500\u2500 game/ # Gestion du monde et des entit\u00e9s de jeu \u2502 \u2502 \u251c\u2500\u2500 camera.py # Gestion de la cam\u00e9ra \u2502 \u2502 \u251c\u2500\u2500 map.py # Gestion de la carte \u2502 \u2502 \u251c\u2500\u2500 player.py # D\u00e9finition du joueur \u2502 \u2502 \u251c\u2500\u2500 player_manager.py # Gestion multi-joueur / joueurs IA \u2502 \u2502 \u2514\u2500\u2500 terrain.py # Gestion des terrains du jeu \u2502 \u2502 \u2502 \u2514\u2500\u2500 input/ # Gestion des entr\u00e9es utilisateur \u2502 \u2514\u2500\u2500 input_manager.py # Mappage clavier/souris et actions \u2502 \u251c\u2500\u2500 enums/ # D\u00e9clarations d\u2019\u00e9num\u00e9rations globales \u2502 \u251c\u2500\u2500 case_type.py # Types de cases \u2502 \u251c\u2500\u2500 input_actions.py # Actions d\u2019entr\u00e9e (clic, fl\u00e8ches, etc.) \u2502 \u251c\u2500\u2500 source_effect.py # Origine des effets (terrain, balise, etc.) \u2502 \u2502 \u2502 \u2514\u2500\u2500 entity/ # Enums li\u00e9es aux entit\u00e9s \u2502 \u251c\u2500\u2500 events/ # \u00c9v\u00e9nements ECS (communication entre syst\u00e8mes) \u2502 \u251c\u2500\u2500 attack_event.py # \u00c9v\u00e9nement d\u2019attaque \u2502 \u251c\u2500\u2500 move_order_event.py # Ordre de mouvement \u2502 \u251c\u2500\u2500 select_event.py # S\u00e9lection d\u2019unit\u00e9 \u2502 \u251c\u2500\u2500 spawn_unit_event.py # Apparition d\u2019unit\u00e9 \u2502 \u251c\u2500\u2500 death_event.py # Mort d\u2019une entit\u00e9 \u2502 \u251c\u2500\u2500 victory_event.py # Condition de victoire \u2502 \u2514\u2500\u2500 ... # (autres \u00e9v\u00e9nements cam\u00e9ra, zoom, etc.) \u2502 \u251c\u2500\u2500 factories/ # Cr\u00e9ation d\u2019entit\u00e9s et d\u2019unit\u00e9s \u2502 \u251c\u2500\u2500 entity_factory.py # Fabrique d\u2019entit\u00e9s g\u00e9n\u00e9riques \u2502 \u2514\u2500\u2500 unit_factory.py # Fabrique d\u2019unit\u00e9s sp\u00e9cifiques (charg\u00e9es depuis la configuration) \u2502 \u251c\u2500\u2500 systems/ # Syst\u00e8mes ECS (logique du jeu) \u2502 \u251c\u2500\u2500 combat/ # Syst\u00e8mes de combat (fl\u00e8ches, cibles, troupes) \u2502 \u251c\u2500\u2500 input/ # Syst\u00e8mes li\u00e9s aux entr\u00e9es et cam\u00e9ra \u2502 \u251c\u2500\u2500 rendering/ # Syst\u00e8mes d\u2019affichage et HUD \u2502 \u251c\u2500\u2500 world/ # Syst\u00e8mes du monde (\u00e9conomie, mouvement, collisions) \u2502 \u251c\u2500\u2500 death_event_handler.py # Gestion de la mort des entit\u00e9s \u2502 \u251c\u2500\u2500 quit_system.py # Fermeture propre du jeu \u2502 \u2514\u2500\u2500 victory_system.py # Gestion des conditions de victoire \u2502 \u2514\u2500\u2500 ui/ # Interface utilisateur \u2502 \u2514\u2500\u2500 hud.py # Affichage du HUD (interface de jeu)","title":"8. Structure du code source"},{"location":"ADMIN_DOCS/#81-description-des-modules-principaux","text":"Module R\u00f4le et responsabilit\u00e9s main.py Point d\u2019entr\u00e9e du jeu. Initialise le moteur, charge la configuration et lance la boucle principale. Ouvre le menu principal du jeu. core/ Contient le moteur principal et les services. Gestion de la boucle de jeu, des entit\u00e9s, \u00e9v\u00e9nements et entr\u00e9es. core/ecs/ Impl\u00e9mente le pattern ECS : d\u00e9finition des entit\u00e9s, composants, syst\u00e8mes et bus d\u2019\u00e9v\u00e9nements. components/ D\u00e9finit les composants r\u00e9utilisables : sant\u00e9, position, attaque, etc. systems/ Contient la logique du jeu par syst\u00e8me : combat, mouvement, rendu, \u00e9conomie, input, etc. Chaque syst\u00e8me manipule les entit\u00e9s via leurs composants. config/ Fichiers de configuration : unit\u00e9s, terrains, couches de rendu. Permet de modifier les param\u00e8tres du jeu sans changer le code. enums/ D\u00e9clarations d\u2019\u00e9num\u00e9rations globales pour types d\u2019entit\u00e9s, actions, effets et cases. events/ \u00c9v\u00e9nements ECS pour la communication entre syst\u00e8mes (attaques, mouvements, s\u00e9lections, victoire, mort). factories/ Cr\u00e9ation et initialisation des entit\u00e9s \u00e0 partir des composants et des fichiers de configuration. ui/ Gestion du HUD et de l\u2019interface utilisateur. Affiche les informations du joueur et l\u2019\u00e9tat du jeu. Permet au joueur de voir et d'int\u00e9ragir avec le jeu.","title":"8.1 Description des modules principaux"},{"location":"ADMIN_DOCS/#9-fichiers-de-donnees","text":"Le jeu utilise plusieurs types de fichiers de donn\u00e9es externes : Dossier / Fichier R\u00f4le Format / Contenu config/layer.py D\u00e9finit les couches d\u2019affichage du moteur (priorit\u00e9 de rendu). Script Python config/terrains.py Sp\u00e9cifie les types de terrains et leurs effets sur les unit\u00e9s. Script Python config/units.py D\u00e9finit les caract\u00e9ristiques de chaque unit\u00e9 (PV, attaque, port\u00e9e, co\u00fbt). Script Python assets/ Contient les ressources graphiques et audio du jeu. Images et sons config.yaml Contient les configurations g\u00e9n\u00e9rales et les textes Donn\u00e9es au format YAML","title":"9. Fichiers de donn\u00e9es"},{"location":"ADMIN_DOCS/#10-securite-et-integrite","text":"Le jeu applique plusieurs m\u00e9canismes pour assurer la s\u00e9curit\u00e9 et l\u2019int\u00e9grit\u00e9 des donn\u00e9es : Validation des entr\u00e9es utilisateur Toutes les entr\u00e9es sont contr\u00f4l\u00e9es avant traitement (clavier, souris, s\u00e9lection d\u2019unit\u00e9) pour \u00e9viter les \u00e9tats invalides. Int\u00e9grit\u00e9 des fichiers de configuration et ressources Les fichiers de /config/ et /assets/ sont v\u00e9rifi\u00e9s au lancement pour garantir qu\u2019ils sont complets et coh\u00e9rents. Int\u00e9grit\u00e9 des entit\u00e9s et du moteur ECS Les syst\u00e8mes (combat, mouvement, rendu) appliquent des contraintes pour \u00e9viter les actions ill\u00e9gales (attaques sur unit\u00e9s mortes, mouvements hors carte).","title":"10. S\u00e9curit\u00e9 et int\u00e9grit\u00e9"},{"location":"ADMIN_DOCS/#11-maintenance-et-mise-a-jour","text":"","title":"11. Maintenance et mise \u00e0 jour"},{"location":"ADMIN_DOCS/#mise-a-jour-du-jeu","text":"Tirer les derni\u00e8res modifications : git pull origin main","title":"Mise \u00e0 jour du jeu :"},{"location":"ADMIN_DOCS/#ajout-de-nouvelles-entites","text":"Cr\u00e9er le nouveau type d'entit\u00e9 dans enums/entity/entity_type.py Ajouter dans la constante UNITS la cl\u00e9 correspondant \u00e0 l'entit\u00e9 et lui assigner un objet entit\u00e9 contenant les composants correspondants \u00e0 l'entit\u00e9 UNITS = { EntityType.NEW : Entity( components=[ #Liste des composants de l''entit\u00e9 ]) }","title":"Ajout de nouvelles entit\u00e9s :"},{"location":"ADMIN_DOCS/#12-erreurs-courantes-et-solutions","text":"Erreur Cause possible Solution ModuleNotFoundError: No module named 'pygame' Pygame non install\u00e9 ou mauvaise version Ex\u00e9cuter pip install -r requirements.txt ou v\u00e9rifier la version de Python et Pygame Une unit\u00e9 ne r\u00e9pond pas aux ordres Composants manquants ou mal initialis\u00e9s dans UNITS V\u00e9rifier que tous les composants n\u00e9cessaires sont inclus et correctement import\u00e9s Erreur de chargement d\u2019un fichier de configuration Fichier manquant ou syntaxe invalide dans config/*.py ou config.yaml V\u00e9rifier la pr\u00e9sence du fichier et sa syntaxe. Pour YAML, utiliser un validateur YAML Actions utilisateur non d\u00e9tect\u00e9es (clic, touches) Mauvais mapping clavier/souris ou conflit dans input_manager.py V\u00e9rifier que input_actions.py correspond aux touches utilis\u00e9es et que input_manager est bien initialis\u00e9 Sprites ou ressources graphiques manquants Fichier absent dans assets/ ou chemin incorrect V\u00e9rifier la pr\u00e9sence et le chemin des fichiers images/audio utilis\u00e9s par les composants sprite Probl\u00e8me de cam\u00e9ra Mauvaise r\u00e9cup\u00e9ration de la taille de la fen\u00eatre Redimensionner la fen\u00eatre Impossible de cloner ou pull le d\u00e9p\u00f4t Git Probl\u00e8me de droits ou URL incorrecte V\u00e9rifier l\u2019URL et vos droits Git, utiliser git clone https://github.com/Zwartkat/Clash-of-Piglin","title":"12. Erreurs courantes et solutions"},{"location":"ADMIN_DOCS/#13-glossaire","text":"Terme D\u00e9finition ECS (Entity-Component-System) Architecture logicielle qui s\u00e9pare les entit\u00e9s (objets du jeu), leurs composants (donn\u00e9es) et les syst\u00e8mes (logique de traitement). Entit\u00e9 (Entity) Objet du jeu unique (unit\u00e9, b\u00e2timent, projectile) constitu\u00e9 d\u2019un ou plusieurs composants. Composant (Component) Conteneur de donn\u00e9es d\u2019une entit\u00e9 (ex : sant\u00e9, position, vitesse, attaque). Syst\u00e8me (System) Module qui applique la logique du jeu aux entit\u00e9s selon leurs composants (ex : combat, mouvement, rendu). Event / \u00c9v\u00e9nement Message ou signal envoy\u00e9 entre syst\u00e8mes pour d\u00e9clencher des actions (ex : attaque, d\u00e9placement, mort). Bus d\u2019\u00e9v\u00e9nements (Event Bus) M\u00e9canisme centralis\u00e9 pour diffuser les \u00e9v\u00e9nements aux syst\u00e8mes concern\u00e9s. HUD (Head-Up Display) Interface utilisateur affichant les informations de jeu : ressources, points de vie, s\u00e9lection d\u2019unit\u00e9s. Configuration (Config) Fichiers ou scripts d\u00e9finissant les param\u00e8tres du jeu, comme les unit\u00e9s, terrains et couches de rendu. Assets Ressources graphiques et audio utilis\u00e9es par le jeu (images, sprites, sons). Python Langage de programmation utilis\u00e9 pour d\u00e9velopper le jeu. Pygame Biblioth\u00e8que Python utilis\u00e9e pour g\u00e9rer les graphismes, les entr\u00e9es et le son. Terrain Case ou zone du jeu qui peuvent avoir des propri\u00e9t\u00e9s particuli\u00e8res (effets sur le mouvement, etc.). R\u00e9pertoire racine ( src/ ) Dossier contenant l\u2019ensemble du code source et des modules du jeu.","title":"13. Glossaire"},{"location":"ADMIN_DOCS/#14-support-et-contact","text":"Pour tout probl\u00e8me ou question, contacter : Zwartkat, lorenzovdkn, darkell, workai, SparkasselaBank ou MatthieuPinceel en passant par GitHub Issues Lien du d\u00e9p\u00f4t : https://github.com/Zwartkat/Clash-of-Piglin Cette documentation pour Clash of Piglin respecte les pr\u00e9conisations de la norme ISO/IEC/IEEE 26514.","title":"14. Support et contact"},{"location":"AI_Crossbowman_Report/","text":"Rapport technique \u2014 IA CROSSBOWMAN Date : 26-10-2025 Vid\u00e9o de d\u00e9monstration Vous pouvez visionner une d\u00e9monstration de l'IA ici : D\u00e9monstration IA CROSSBOWMAN 1) Identit\u00e9 et contexte Auteur : Lorenzo Vandenkoornhuyse Jeu : Clash\u2011of\u2011piglin Unit\u00e9 cibl\u00e9e : CROSSBOWMAN (IA pour l'\u00e9quipe ennemie) Ce document d\u00e9crit o\u00f9 se trouve le code, la strat\u00e9gie appliqu\u00e9e et les algorithmes utilis\u00e9s pour l'IA des Crossbowmen. 2) Emplacement du code (branche) Branche Git contenant les modifications : IA_VANDENKOORNHUYSE Fichiers principaux modifi\u00e9s : src/systems/crossbowman_ai_system_enemy.py \u2014 logique principale de l'IA (process, d\u00e9cision tactique, support BRUTE, group assault, d\u00e9fenses). src/components/ai.py \u2014 composant AIMemory . src/systems/ai_helpers.py \u2014 helpers pour la coordination BRUTE, gestion de bastion, priorisation et mouvements. src/events/event_move.py / src/events/event_move_to.py \u2014 \u00e9v\u00e9nements de mouvement utilis\u00e9s ( EventMoveTo ). src/systems/pathfinding_system.py il utilise PathRequest (A*). config.yaml \u2014 configurations g\u00e9n\u00e9rales; options debug (ex. debug.give_gold.* ). src/systems/economy_system.py , src/systems/input_manager.py , src/systems/input_router_system.py \u2014 int\u00e9gration du raccourci debug (donner de l'or avec \"g\" ou \"f3\" pour voir le calcul des chemins et les blocs de collisions en rouge). Point d'entr\u00e9e pour tests locaux : src/main.py . 3) Strat\u00e9gie mise en \u0153uvre (diagramme) 4) Algorithmes et consid\u00e9rations techniques Pathfinding : A* (impl\u00e9ment\u00e9 par le PathfindingSystem via le composant PathRequest ). L'IA v\u00e9rifie d'abord si la trajectoire directe est s\u00fbre ( _is_direct_path_safe ). Si non s\u00fbre (ex : lave), elle cr\u00e9e/actualise un PathRequest pour que le PathfindingSystem calcule un chemin A*. Estimation de force locale : points attribu\u00e9s aux unit\u00e9s (BRUTE=3, CROSSBOWMAN=5, GHAST=8). Somme des points pour alli\u00e9s et ennemis dans un rayon donn\u00e9 -> comparaison. Branching logique (voir diagramme) : GHAST > BRUTE support > base defense > force-based decisions. Group tactics / recrutement : approche gloutonne locale : Recrutement d'alli\u00e9s dans un rayon RECRUIT_RADIUS (ex. 500 px). Placement en formation circulaire autour de la cible \u00e0 safe_distance calcul\u00e9e depuis attack.range . BRUTE assignment : Chaque tick, on initialise _brute_assignment_counts \u00e0 partir des AIMemory existants et on incr\u00e9mente lorsque l'on r\u00e9serve une BRUTE. AIMemory.assigned_brute_id permet de maintenir l'affectation entre ticks pour emp\u00eacher des r\u00e9affectations inutiles. Mouvements : Mouvement direct via EventMoveTo si le chemin direct est s\u00fbr. Sinon, cr\u00e9ation d'un PathRequest pour d\u00e9clencher l'A*. 5) Suggestions d'am\u00e9liorations futures Ajuster les poids du syst\u00e8me de force (BRUTE/CROSSBOWMAN/GHAST) via configuration plut\u00f4t que constantes cod\u00e9es en dur. Ajouter des tests automatis\u00e9s (unitaires) pour les fonctions pures : calcul de force, s\u00e9lection de BRUTE, placement d'assaut.","title":"Rapport technique \u2014 IA CROSSBOWMAN"},{"location":"AI_Crossbowman_Report/#rapport-technique-ia-crossbowman","text":"Date : 26-10-2025","title":"Rapport technique \u2014 IA CROSSBOWMAN"},{"location":"AI_Crossbowman_Report/#video-de-demonstration","text":"Vous pouvez visionner une d\u00e9monstration de l'IA ici : D\u00e9monstration IA CROSSBOWMAN","title":"Vid\u00e9o de d\u00e9monstration"},{"location":"AI_Crossbowman_Report/#1-identite-et-contexte","text":"Auteur : Lorenzo Vandenkoornhuyse Jeu : Clash\u2011of\u2011piglin Unit\u00e9 cibl\u00e9e : CROSSBOWMAN (IA pour l'\u00e9quipe ennemie) Ce document d\u00e9crit o\u00f9 se trouve le code, la strat\u00e9gie appliqu\u00e9e et les algorithmes utilis\u00e9s pour l'IA des Crossbowmen.","title":"1) Identit\u00e9 et contexte"},{"location":"AI_Crossbowman_Report/#2-emplacement-du-code-branche","text":"Branche Git contenant les modifications : IA_VANDENKOORNHUYSE Fichiers principaux modifi\u00e9s : src/systems/crossbowman_ai_system_enemy.py \u2014 logique principale de l'IA (process, d\u00e9cision tactique, support BRUTE, group assault, d\u00e9fenses). src/components/ai.py \u2014 composant AIMemory . src/systems/ai_helpers.py \u2014 helpers pour la coordination BRUTE, gestion de bastion, priorisation et mouvements. src/events/event_move.py / src/events/event_move_to.py \u2014 \u00e9v\u00e9nements de mouvement utilis\u00e9s ( EventMoveTo ). src/systems/pathfinding_system.py il utilise PathRequest (A*). config.yaml \u2014 configurations g\u00e9n\u00e9rales; options debug (ex. debug.give_gold.* ). src/systems/economy_system.py , src/systems/input_manager.py , src/systems/input_router_system.py \u2014 int\u00e9gration du raccourci debug (donner de l'or avec \"g\" ou \"f3\" pour voir le calcul des chemins et les blocs de collisions en rouge). Point d'entr\u00e9e pour tests locaux : src/main.py .","title":"2) Emplacement du code (branche)"},{"location":"AI_Crossbowman_Report/#3-strategie-mise-en-uvre-diagramme","text":"","title":"3) Strat\u00e9gie mise en \u0153uvre (diagramme)"},{"location":"AI_Crossbowman_Report/#4-algorithmes-et-considerations-techniques","text":"Pathfinding : A* (impl\u00e9ment\u00e9 par le PathfindingSystem via le composant PathRequest ). L'IA v\u00e9rifie d'abord si la trajectoire directe est s\u00fbre ( _is_direct_path_safe ). Si non s\u00fbre (ex : lave), elle cr\u00e9e/actualise un PathRequest pour que le PathfindingSystem calcule un chemin A*. Estimation de force locale : points attribu\u00e9s aux unit\u00e9s (BRUTE=3, CROSSBOWMAN=5, GHAST=8). Somme des points pour alli\u00e9s et ennemis dans un rayon donn\u00e9 -> comparaison. Branching logique (voir diagramme) : GHAST > BRUTE support > base defense > force-based decisions. Group tactics / recrutement : approche gloutonne locale : Recrutement d'alli\u00e9s dans un rayon RECRUIT_RADIUS (ex. 500 px). Placement en formation circulaire autour de la cible \u00e0 safe_distance calcul\u00e9e depuis attack.range . BRUTE assignment : Chaque tick, on initialise _brute_assignment_counts \u00e0 partir des AIMemory existants et on incr\u00e9mente lorsque l'on r\u00e9serve une BRUTE. AIMemory.assigned_brute_id permet de maintenir l'affectation entre ticks pour emp\u00eacher des r\u00e9affectations inutiles. Mouvements : Mouvement direct via EventMoveTo si le chemin direct est s\u00fbr. Sinon, cr\u00e9ation d'un PathRequest pour d\u00e9clencher l'A*.","title":"4) Algorithmes et consid\u00e9rations techniques"},{"location":"AI_Crossbowman_Report/#5-suggestions-dameliorations-futures","text":"Ajuster les poids du syst\u00e8me de force (BRUTE/CROSSBOWMAN/GHAST) via configuration plut\u00f4t que constantes cod\u00e9es en dur. Ajouter des tests automatis\u00e9s (unitaires) pour les fonctions pures : calcul de force, s\u00e9lection de BRUTE, placement d'assaut.","title":"5) Suggestions d'am\u00e9liorations futures"},{"location":"DOCS_TECHNICAL/","text":"Clash-of-piglin Tutoriels ... Afficher un \u00e9lement dans la map Les coordonn\u00e9es trait\u00e9es en arri\u00e8re plan sont les coordonn\u00e9es de l'\u00e9l\u00e9ment dans le monde , celui n'est cependant pas afficher \u00e0 cet emplacement. Pour afficher un \u00e9l\u00e9ment sur la carte, il est imp\u00e9ratif de passer par la Camera . Il n'est pas n\u00e9cessaire d'acc\u00e9der directement \u00e0 la cam\u00e9ra pour afficher l'\u00e9l\u00e9ment souhait\u00e9. La classe RenderSystem permet directement de passer l'\u00e9l\u00e9ment souhait\u00e9 pour l'afficher dans la carte Pour cela, on doit r\u00e9cup\u00e9rer l'instance de RenderSystem est utiliser les m\u00e9thodes suivantes: - draw_surface : pour afficher une Surface pygame - draw_rect : pour dessiner un Rect de pygame - draw_polygon : pour dessiner un Polygon de pygame from systems.rendersystem import RenderSystem screen : pygame.Surface map : Map sprites : dict[CaseType,pygame.Surface] render = RenderSystem(screen,map,sprites) frame = sprite.get_frame() render.draw_surface(frame, x, y) render.draw_rect((x, y, width, height), color) diamond_points: list[tuple[int]] = [ (x, y - 10), # Top (x + 2, y - 8), # right (x, y - 6), # bottom (x - 2, y - 8), # left ] render.draw_polygon(diamond_points, color) Animer une entit\u00e9 L'animation d'une entit\u00e9 d\u00e9pend du composant Sprite \u00e0 sa cr\u00e9ation. La frame courante peut ensuite \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir de la m\u00e9thode get_frame . La m\u00e9thode set_animation permet de d\u00e9finir l'animation et la direction \u00e0 afficher. Elle est g\u00e9n\u00e9ralement utilis\u00e9e dans des m\u00e9thodes appel\u00e9es par l'\u00e9mission d'un Event . Voir EventBus Le Sprite est mis \u00e0 jour via la m\u00e9thode update , qui utilise le delta_time pour d\u00e9cider du changement de frame. Le RenderSystem permet d'effectuer automatiquement la mise \u00e0 jour de la frame \u00e0 afficher Core EventBus L'EventBus est un syst\u00e8me permettant de transmettre des \u00e9v\u00e9nements \u00e0 n'importe quelle m\u00e9thode de classe abonn\u00e9 Cette classe est sous la forme d'un singleton et peut \u00eatre r\u00e9cup\u00e9r\u00e9e avec EventBus.get_event_bus() . La m\u00e9thode subscribe permet en fournissant une classe Event et une m\u00e9thode sous forme de Callable . Pour d\u00e9sabonner, il faut utiliser unsubcribe . Pour \u00e9mettre un \u00e9v\u00e9nement, il doit \u00eatre donn\u00e9 \u00e0 la m\u00e9thode emit qui ex\u00e9cutera toutes les objets m\u00e9thodes abonn\u00e9s. Ces m\u00e9thodes doivent poss\u00e9der en argument l'event qui lui sera transmis from core.ecs.event_bus import EventBus render = RenderSystem() event_bus : EventBus = EventBus.get_event_bus() event_bus.subscribe(MoveEvent, render.animate_move) class RenderSystem: def __init__(self): pass ... def animate_move(self, event : MoveEvent): print(event.pos_x,event.pos_y) IteratingProcessor La classe IteratingProcessor est une classe abstraite qui permet d'effectuer une action \u00e0 d\u00e9finir dans la classe fille. Elle permet d'executer cette action pour toutes les entit\u00e9s qui poss\u00e8dent les Component fournis \u00e0 l'instanciation de la classe par l'interm\u00e9diaire de la m\u00e9thode process_entity . Celle-ci fournit les donn\u00e9es suivantes: - ent (int) : l'identifiant de l'entit\u00e9 dans esper - dt (float) : le delta_time - *comps (Component) : le ou les components fournis \u00e0 la cr\u00e9ation de la classe fille Exemple from component.component1 import Component1 from component.component2 import Component2 class ExempleSystem(IteratingProcessor): def __init__(self): super().__init__(Component1,Component2) def process_entity(self, ent : int, dt : float, comp1: Component1, comp2 : Component2): pass Cam\u00e9ra La cam\u00e9ra affiche uniquement les \u00e9l\u00e9ments aux coordonn\u00e9es correspondant au delta x et y de la cam\u00e9ra (le d\u00e9calage de la cam\u00e9ra par rapport au monde) Pour utiliser la cam\u00e9ra, il est imp\u00e9ratif d'executer ces deux fonctions : set_size et set_world_size from core.game.camera import CAMERA CAMERA.set_size(300,300) CAMERA.set_world_size(700,800) Composants Toutes les entit\u00e9s sont d\u00e9finis par des composants, ceux-ci servent de stockage de donn\u00e9es. Ils d\u00e9pendent tous de Component . Attack Case L'entit\u00e9 Case permet de cr\u00e9er des cases, qui en nombre composent la carte de jeu ( Map ). On peut en cr\u00e9er sans communiquer de param\u00e8tres. La case sera alors cr\u00e9\u00e9e avec des coordonn\u00e9es ( Position ) et un type ( CaseType ) par d\u00e9faut. On peut cependant \u00e9galement cr\u00e9er une Case \u00e0 partir d'une autre (la nouvelle copiera alors les coordonn\u00e9es et le type du mod\u00e8le) via la m\u00e9thode initFromModel . Les propri\u00e9t\u00e9s d'une Case sont : coordonnees (Position) : La position de la case. Sera utilis\u00e9e pour d\u00e9terminer son placement dans le tab de la carte de jeu, ainsi que pour l'affichage de ladite carte. type (CaseType) : Le type de la case. Sera notamment utilis\u00e9 dans la carte de jeu afin de permettre toute sortes d'op\u00e9rations, dont la v\u00e9rification de la g\u00e9n\u00e9ration d'une carte valide. Si la case est de type LAVA , elle re\u00e7oit un composant Sprite qui sera utilis\u00e9 pour g\u00e9rer une animation lors de l'affichage. Les fonctions d'une carte sont : getPosition () -> Position : retourne les coordonn\u00e9es de la case. getType () -> CaseType : retourne le type de la case. setPosition (mod\u00e8le : Position) -> None : copie la position fourni dans les coordonnees de la case. setType (mod\u00e8le : CaseType) -> None : copie le type fourni dans le type de la case. __str__ () -> str : m\u00e9thode permettant d'afficher une case comme une cha\u00eene de caract\u00e8res d\u00e9crivant sa position et son type. Exemple d'impl\u00e9mentation d'une carte : from components.case import Case case = Case() print(carte) Collider Cost Effects Fly Health Map Le composant Map permet de cr\u00e9er des cartes de jeu, repr\u00e9sent\u00e9es par des tables de Case . On peut en cr\u00e9er sans communiquer de param\u00e8tres. Le tableau repr\u00e9sentant le contenu de la carte sera alors initialis\u00e9 comme vide. On peut cependant \u00e9galement cr\u00e9er une carte \u00e0 partir d'une autre (la nouvelle copiera alors le tableau du mod\u00e8le) via la m\u00e9thode initFromModel , ou cr\u00e9er une carte \u00e0 partir d'un tableau (list[list[CaseType]) (la carte utilisera le tableau pour initialiser le sien) via la m\u00e9thode initFromTab . Les propri\u00e9t\u00e9s d'une carte sont : tab (list[list[Case]]) : Le tableau repr\u00e9sentant le contenu de la carte. index (int) : Un index g\u00e9n\u00e9r\u00e9 \u00e0 partir d'un compteur statique, permettant d'identifier la carte. Les propri\u00e9t\u00e9s statiques des cartes sont : counter (int) : compteur statique s'incr\u00e9mentant \u00e0 chaque cr\u00e9ation de carte, utilis\u00e9 pour d\u00e9terminer l'index des cartes cr\u00e9\u00e9e. list_frequencies (dict[CaseType, int]) : liste statique d\u00e9finissant la fr\u00e9quence des diff\u00e9rents type de cases sur la carte. generate_on_base (list[CaseType]) : liste statique d\u00e9finissant les types de case \u00e0 g\u00e9n\u00e9rer sous les emplacements des bastions. restricted_cases (list[CaseType]) : liste statique d\u00e9finissant les types de case dont la g\u00e9n\u00e9ration doit \u00eatre contr\u00f4l\u00e9e, de sorte que toutes les cases de la carte n'\u00e9tant pas d'un des types pr\u00e9sent dans restricted_cases soient accessibles sans passer par une case d'un des types pr\u00e9sent dans restricted_cases . default_block (CaseType) : type de case statique qui sera utilis\u00e9 pour g\u00e9n\u00e9rer la carte avant l'ajout des autres types de cases. limit_of_generation_for_type (int) : nombre statique repr\u00e9sentant la limite sup\u00e9rieure du nombre de groupe de cases possible pour chaque type de case (Si limit_of_generation_for_type vaut 2, pour chaque type de cases g\u00e9n\u00e9r\u00e9 dans la fonction generate , les cases de ce type peuvent \u00eatre r\u00e9parties en 1 \u00e0 2 groupes de tailles identiques). Money Position Selection Sprite Le component Sprite permet d'ajouter un sprite \u00e0 une entit\u00e9. Voir Animer une entit\u00e9 Les param\u00e8tres \u00e0 fournir sont : sprite_sheet (str) : La feuille de sprite \u00e0 utiliser pour l'animation. width (int) : La largeur des frames sur la feuille de sprite. height (int) : La hauteur des frames sur la feuille de sprite. animations (dict) : Le d\u00e9tail des animations (voir ci-dessous). frame_duration (float) : La dur\u00e9e en secondes d'une frame. spritesheet_direction (Orientation) : Orientation des frames dans la feuille (HORIZONTAL ou VERTICAL). D\u00e9faut = HORIZONTAL . default_animation (Animation) : L'animation par d\u00e9faut de l'entit\u00e9. D\u00e9faut = IDLE . default_direction (Direction) : La direction par d\u00e9faut de l'entit\u00e9. D\u00e9faut = DOWN . Le param\u00e8tre animations est un dictionnaire qui associe pour chaque type d'animation et pour chaque direction, une liste d'entiers correspondant aux indices des frames sur la feuille de sprite (la premi\u00e8re frame = 0). Exemple de param\u00e8tre animation: { Animation.IDLE: { Direction.DOWN: [1, 5], Direction.UP: [3, 7], Direction.LEFT: [2, 6], Direction.RIGHT: [0, 4], }, Animation.WALK: { Direction.DOWN: [1, 10, 1, 11], Direction.UP: [3, 14, 3, 15], Direction.LEFT: [2, 12, 2, 13], Direction.RIGHT: [0, 8, 0, 9], }, } Squad Stats Structure Target Team Velocity Syst\u00e8mes ... RenderSystem RenderSystem est une classe qui g\u00e8re de fa\u00e7on globale l'affichage. Elle h\u00e9rite de IteratingProcessor ce qui permet d'effectuer des actions sur chaque entit\u00e9s poss\u00e9dant un composant Position et Sprite . Avant l'ex\u00e9cution du process_entity , les entit\u00e9s sont tri\u00e9s par Layer d\u00e9finie par la propri\u00e9t\u00e9 priority de Sprite Son process_entity va afficher les entit\u00e9s concern\u00e9es et \u00e9galement mettre \u00e0 jour l'animation. Lorsque le type d'animation ne vaut pas None , l'entit\u00e9 est consid\u00e9r\u00e9 comme un personnage jouable. Dans ce cas, une barre de vie lui ai ajout\u00e9 au dessus du sprite ainsi qu'un point avec une couleur r\u00e9pr\u00e9sentant son \u00e9quipe et son \u00e9tat de s\u00e9lection. A sa cr\u00e9ation RenderSystem a besoin des 3 \u00e9l\u00e9ments suivants : - une Surface issue de pygame - une Map - un dictionnaire de sprite pour les cases : dict[CaseType,pygame.Surface] M\u00e9thodes : - show_map : affiche la carte (carte d\u00e9finie \u00e0 l'instanciation) - animate_move : m\u00e9thode qui passe les animations de sprite des entit\u00e9s fournit par EventMoveTo - draw_surface : Dessine une surface pygame sur le screen du RenderSystem - draw_rect : Dessine une surface pygame sur le screen du RenderSystem - draw_polygon : Dessine une surface pygame sur le screen du RenderSystem","title":"Clash-of-piglin"},{"location":"DOCS_TECHNICAL/#clash-of-piglin","text":"","title":"Clash-of-piglin"},{"location":"DOCS_TECHNICAL/#tutoriels","text":"...","title":"Tutoriels"},{"location":"DOCS_TECHNICAL/#afficher-un-element-dans-la-map","text":"Les coordonn\u00e9es trait\u00e9es en arri\u00e8re plan sont les coordonn\u00e9es de l'\u00e9l\u00e9ment dans le monde , celui n'est cependant pas afficher \u00e0 cet emplacement. Pour afficher un \u00e9l\u00e9ment sur la carte, il est imp\u00e9ratif de passer par la Camera . Il n'est pas n\u00e9cessaire d'acc\u00e9der directement \u00e0 la cam\u00e9ra pour afficher l'\u00e9l\u00e9ment souhait\u00e9. La classe RenderSystem permet directement de passer l'\u00e9l\u00e9ment souhait\u00e9 pour l'afficher dans la carte Pour cela, on doit r\u00e9cup\u00e9rer l'instance de RenderSystem est utiliser les m\u00e9thodes suivantes: - draw_surface : pour afficher une Surface pygame - draw_rect : pour dessiner un Rect de pygame - draw_polygon : pour dessiner un Polygon de pygame from systems.rendersystem import RenderSystem screen : pygame.Surface map : Map sprites : dict[CaseType,pygame.Surface] render = RenderSystem(screen,map,sprites) frame = sprite.get_frame() render.draw_surface(frame, x, y) render.draw_rect((x, y, width, height), color) diamond_points: list[tuple[int]] = [ (x, y - 10), # Top (x + 2, y - 8), # right (x, y - 6), # bottom (x - 2, y - 8), # left ] render.draw_polygon(diamond_points, color)","title":"Afficher un \u00e9lement dans la map"},{"location":"DOCS_TECHNICAL/#animer-une-entite","text":"L'animation d'une entit\u00e9 d\u00e9pend du composant Sprite \u00e0 sa cr\u00e9ation. La frame courante peut ensuite \u00eatre r\u00e9cup\u00e9r\u00e9e \u00e0 partir de la m\u00e9thode get_frame . La m\u00e9thode set_animation permet de d\u00e9finir l'animation et la direction \u00e0 afficher. Elle est g\u00e9n\u00e9ralement utilis\u00e9e dans des m\u00e9thodes appel\u00e9es par l'\u00e9mission d'un Event . Voir EventBus Le Sprite est mis \u00e0 jour via la m\u00e9thode update , qui utilise le delta_time pour d\u00e9cider du changement de frame. Le RenderSystem permet d'effectuer automatiquement la mise \u00e0 jour de la frame \u00e0 afficher","title":"Animer une entit\u00e9"},{"location":"DOCS_TECHNICAL/#core","text":"","title":"Core"},{"location":"DOCS_TECHNICAL/#eventbus","text":"L'EventBus est un syst\u00e8me permettant de transmettre des \u00e9v\u00e9nements \u00e0 n'importe quelle m\u00e9thode de classe abonn\u00e9 Cette classe est sous la forme d'un singleton et peut \u00eatre r\u00e9cup\u00e9r\u00e9e avec EventBus.get_event_bus() . La m\u00e9thode subscribe permet en fournissant une classe Event et une m\u00e9thode sous forme de Callable . Pour d\u00e9sabonner, il faut utiliser unsubcribe . Pour \u00e9mettre un \u00e9v\u00e9nement, il doit \u00eatre donn\u00e9 \u00e0 la m\u00e9thode emit qui ex\u00e9cutera toutes les objets m\u00e9thodes abonn\u00e9s. Ces m\u00e9thodes doivent poss\u00e9der en argument l'event qui lui sera transmis from core.ecs.event_bus import EventBus render = RenderSystem() event_bus : EventBus = EventBus.get_event_bus() event_bus.subscribe(MoveEvent, render.animate_move) class RenderSystem: def __init__(self): pass ... def animate_move(self, event : MoveEvent): print(event.pos_x,event.pos_y)","title":"EventBus"},{"location":"DOCS_TECHNICAL/#iteratingprocessor","text":"La classe IteratingProcessor est une classe abstraite qui permet d'effectuer une action \u00e0 d\u00e9finir dans la classe fille. Elle permet d'executer cette action pour toutes les entit\u00e9s qui poss\u00e8dent les Component fournis \u00e0 l'instanciation de la classe par l'interm\u00e9diaire de la m\u00e9thode process_entity . Celle-ci fournit les donn\u00e9es suivantes: - ent (int) : l'identifiant de l'entit\u00e9 dans esper - dt (float) : le delta_time - *comps (Component) : le ou les components fournis \u00e0 la cr\u00e9ation de la classe fille Exemple from component.component1 import Component1 from component.component2 import Component2 class ExempleSystem(IteratingProcessor): def __init__(self): super().__init__(Component1,Component2) def process_entity(self, ent : int, dt : float, comp1: Component1, comp2 : Component2): pass","title":"IteratingProcessor"},{"location":"DOCS_TECHNICAL/#camera","text":"La cam\u00e9ra affiche uniquement les \u00e9l\u00e9ments aux coordonn\u00e9es correspondant au delta x et y de la cam\u00e9ra (le d\u00e9calage de la cam\u00e9ra par rapport au monde) Pour utiliser la cam\u00e9ra, il est imp\u00e9ratif d'executer ces deux fonctions : set_size et set_world_size from core.game.camera import CAMERA CAMERA.set_size(300,300) CAMERA.set_world_size(700,800)","title":"Cam\u00e9ra"},{"location":"DOCS_TECHNICAL/#composants","text":"Toutes les entit\u00e9s sont d\u00e9finis par des composants, ceux-ci servent de stockage de donn\u00e9es. Ils d\u00e9pendent tous de Component .","title":"Composants"},{"location":"DOCS_TECHNICAL/#attack","text":"","title":"Attack"},{"location":"DOCS_TECHNICAL/#case","text":"L'entit\u00e9 Case permet de cr\u00e9er des cases, qui en nombre composent la carte de jeu ( Map ). On peut en cr\u00e9er sans communiquer de param\u00e8tres. La case sera alors cr\u00e9\u00e9e avec des coordonn\u00e9es ( Position ) et un type ( CaseType ) par d\u00e9faut. On peut cependant \u00e9galement cr\u00e9er une Case \u00e0 partir d'une autre (la nouvelle copiera alors les coordonn\u00e9es et le type du mod\u00e8le) via la m\u00e9thode initFromModel . Les propri\u00e9t\u00e9s d'une Case sont : coordonnees (Position) : La position de la case. Sera utilis\u00e9e pour d\u00e9terminer son placement dans le tab de la carte de jeu, ainsi que pour l'affichage de ladite carte. type (CaseType) : Le type de la case. Sera notamment utilis\u00e9 dans la carte de jeu afin de permettre toute sortes d'op\u00e9rations, dont la v\u00e9rification de la g\u00e9n\u00e9ration d'une carte valide. Si la case est de type LAVA , elle re\u00e7oit un composant Sprite qui sera utilis\u00e9 pour g\u00e9rer une animation lors de l'affichage. Les fonctions d'une carte sont : getPosition () -> Position : retourne les coordonn\u00e9es de la case. getType () -> CaseType : retourne le type de la case. setPosition (mod\u00e8le : Position) -> None : copie la position fourni dans les coordonnees de la case. setType (mod\u00e8le : CaseType) -> None : copie le type fourni dans le type de la case. __str__ () -> str : m\u00e9thode permettant d'afficher une case comme une cha\u00eene de caract\u00e8res d\u00e9crivant sa position et son type. Exemple d'impl\u00e9mentation d'une carte : from components.case import Case case = Case() print(carte)","title":"Case"},{"location":"DOCS_TECHNICAL/#collider","text":"","title":"Collider"},{"location":"DOCS_TECHNICAL/#cost","text":"","title":"Cost"},{"location":"DOCS_TECHNICAL/#effects","text":"","title":"Effects"},{"location":"DOCS_TECHNICAL/#fly","text":"","title":"Fly"},{"location":"DOCS_TECHNICAL/#health","text":"","title":"Health"},{"location":"DOCS_TECHNICAL/#map","text":"Le composant Map permet de cr\u00e9er des cartes de jeu, repr\u00e9sent\u00e9es par des tables de Case . On peut en cr\u00e9er sans communiquer de param\u00e8tres. Le tableau repr\u00e9sentant le contenu de la carte sera alors initialis\u00e9 comme vide. On peut cependant \u00e9galement cr\u00e9er une carte \u00e0 partir d'une autre (la nouvelle copiera alors le tableau du mod\u00e8le) via la m\u00e9thode initFromModel , ou cr\u00e9er une carte \u00e0 partir d'un tableau (list[list[CaseType]) (la carte utilisera le tableau pour initialiser le sien) via la m\u00e9thode initFromTab . Les propri\u00e9t\u00e9s d'une carte sont : tab (list[list[Case]]) : Le tableau repr\u00e9sentant le contenu de la carte. index (int) : Un index g\u00e9n\u00e9r\u00e9 \u00e0 partir d'un compteur statique, permettant d'identifier la carte. Les propri\u00e9t\u00e9s statiques des cartes sont : counter (int) : compteur statique s'incr\u00e9mentant \u00e0 chaque cr\u00e9ation de carte, utilis\u00e9 pour d\u00e9terminer l'index des cartes cr\u00e9\u00e9e. list_frequencies (dict[CaseType, int]) : liste statique d\u00e9finissant la fr\u00e9quence des diff\u00e9rents type de cases sur la carte. generate_on_base (list[CaseType]) : liste statique d\u00e9finissant les types de case \u00e0 g\u00e9n\u00e9rer sous les emplacements des bastions. restricted_cases (list[CaseType]) : liste statique d\u00e9finissant les types de case dont la g\u00e9n\u00e9ration doit \u00eatre contr\u00f4l\u00e9e, de sorte que toutes les cases de la carte n'\u00e9tant pas d'un des types pr\u00e9sent dans restricted_cases soient accessibles sans passer par une case d'un des types pr\u00e9sent dans restricted_cases . default_block (CaseType) : type de case statique qui sera utilis\u00e9 pour g\u00e9n\u00e9rer la carte avant l'ajout des autres types de cases. limit_of_generation_for_type (int) : nombre statique repr\u00e9sentant la limite sup\u00e9rieure du nombre de groupe de cases possible pour chaque type de case (Si limit_of_generation_for_type vaut 2, pour chaque type de cases g\u00e9n\u00e9r\u00e9 dans la fonction generate , les cases de ce type peuvent \u00eatre r\u00e9parties en 1 \u00e0 2 groupes de tailles identiques).","title":"Map"},{"location":"DOCS_TECHNICAL/#money","text":"","title":"Money"},{"location":"DOCS_TECHNICAL/#position","text":"","title":"Position"},{"location":"DOCS_TECHNICAL/#selection","text":"","title":"Selection"},{"location":"DOCS_TECHNICAL/#sprite","text":"Le component Sprite permet d'ajouter un sprite \u00e0 une entit\u00e9. Voir Animer une entit\u00e9 Les param\u00e8tres \u00e0 fournir sont : sprite_sheet (str) : La feuille de sprite \u00e0 utiliser pour l'animation. width (int) : La largeur des frames sur la feuille de sprite. height (int) : La hauteur des frames sur la feuille de sprite. animations (dict) : Le d\u00e9tail des animations (voir ci-dessous). frame_duration (float) : La dur\u00e9e en secondes d'une frame. spritesheet_direction (Orientation) : Orientation des frames dans la feuille (HORIZONTAL ou VERTICAL). D\u00e9faut = HORIZONTAL . default_animation (Animation) : L'animation par d\u00e9faut de l'entit\u00e9. D\u00e9faut = IDLE . default_direction (Direction) : La direction par d\u00e9faut de l'entit\u00e9. D\u00e9faut = DOWN . Le param\u00e8tre animations est un dictionnaire qui associe pour chaque type d'animation et pour chaque direction, une liste d'entiers correspondant aux indices des frames sur la feuille de sprite (la premi\u00e8re frame = 0). Exemple de param\u00e8tre animation: { Animation.IDLE: { Direction.DOWN: [1, 5], Direction.UP: [3, 7], Direction.LEFT: [2, 6], Direction.RIGHT: [0, 4], }, Animation.WALK: { Direction.DOWN: [1, 10, 1, 11], Direction.UP: [3, 14, 3, 15], Direction.LEFT: [2, 12, 2, 13], Direction.RIGHT: [0, 8, 0, 9], }, }","title":"Sprite"},{"location":"DOCS_TECHNICAL/#squad","text":"","title":"Squad"},{"location":"DOCS_TECHNICAL/#stats","text":"","title":"Stats"},{"location":"DOCS_TECHNICAL/#structure","text":"","title":"Structure"},{"location":"DOCS_TECHNICAL/#target","text":"","title":"Target"},{"location":"DOCS_TECHNICAL/#team","text":"","title":"Team"},{"location":"DOCS_TECHNICAL/#velocity","text":"","title":"Velocity"},{"location":"DOCS_TECHNICAL/#systemes","text":"...","title":"Syst\u00e8mes"},{"location":"DOCS_TECHNICAL/#rendersystem","text":"RenderSystem est une classe qui g\u00e8re de fa\u00e7on globale l'affichage. Elle h\u00e9rite de IteratingProcessor ce qui permet d'effectuer des actions sur chaque entit\u00e9s poss\u00e9dant un composant Position et Sprite . Avant l'ex\u00e9cution du process_entity , les entit\u00e9s sont tri\u00e9s par Layer d\u00e9finie par la propri\u00e9t\u00e9 priority de Sprite Son process_entity va afficher les entit\u00e9s concern\u00e9es et \u00e9galement mettre \u00e0 jour l'animation. Lorsque le type d'animation ne vaut pas None , l'entit\u00e9 est consid\u00e9r\u00e9 comme un personnage jouable. Dans ce cas, une barre de vie lui ai ajout\u00e9 au dessus du sprite ainsi qu'un point avec une couleur r\u00e9pr\u00e9sentant son \u00e9quipe et son \u00e9tat de s\u00e9lection. A sa cr\u00e9ation RenderSystem a besoin des 3 \u00e9l\u00e9ments suivants : - une Surface issue de pygame - une Map - un dictionnaire de sprite pour les cases : dict[CaseType,pygame.Surface] M\u00e9thodes : - show_map : affiche la carte (carte d\u00e9finie \u00e0 l'instanciation) - animate_move : m\u00e9thode qui passe les animations de sprite des entit\u00e9s fournit par EventMoveTo - draw_surface : Dessine une surface pygame sur le screen du RenderSystem - draw_rect : Dessine une surface pygame sur le screen du RenderSystem - draw_polygon : Dessine une surface pygame sur le screen du RenderSystem","title":"RenderSystem"}]}